CHAPTER 1
ABOUT THIS MANUAL
1.1 INTEL 64 AND IA-32 PROCESSORS COVERED IN THIS MANUAL      . . . 1-1
1.2 OVERVIEW OF VOLUME 1: BASIC ARCHITECTURE      .  .  .  . 1-4
1.3 NOTATIONAL CONVENTIONS     .   .  . . . 1-5
1.3.1 Bit and Byte Order      . . . . . . .1-5
1.3.2 Reserved Bits and Software Compatibility     .  .  . . .1-6
1.3.2.1 Instruction Operands     . . . . .1-6
1.3.3 Hexadecimal and Binary Numbers     .  .  .  . . . .1-7
1.3.4 Segmented Addressing      . . . . .1-7
1.3.5 A New Syntax for CPUID, CR, and MSR Values      .  .  .  . .1-7
1.3.6 Exceptions      .  . . . .1-8
1.4 RELATED LITERATURE      . . . . . 1-9

CHAPTER 2
INTEL 64 AND IA-32 ARCHITECTURES
2.1 BRIEF HISTORY OF INTEL 64 AND IA-32 ARCHITECTURE      .  . . 2-1
2.1.1 16-bit Processors and Segmentation (1978)     .  . . . . .2-1
2.1.2 The Intel 286 Processor (1982)    .  .  .  .  . .2-1
2.1.3 The Intel386 Processor (1985)     .  .  .  .  . .2-1
2.1.4 The Intel486 Processor (1989)     .  .  .  .  . .2-1
2.1.5 The Intel Pentium Processor (1993)    .  .  . . . .2-2
2.1.6 The P6 Family of Processors (1995-1999)     .  .  . . .2-2
2.1.7 The Intel Pentium 4 Processor Family (2000-2006)     . .  . . .2-3
2.1.8 The Intel Xeon Processor (2001- 2007)    .  .  . . .2-3
2.1.9 The Intel Pentium M Processor (2003-2006)      .  .  . . .2-3
2.1.10 The Intel Pentium Processor Extreme Edition (2005)      . . . . . .2-4
2.1.11 The Intel Core Duo and Intel Core Solo Processors (2006-2007)    .   .  .  . .2-4
2.1.12 The Intel Xeon Processor 5100, 5300 Series and Intel Core2 Processor Family (2006)     . . .2-4
2.1.13 The Intel Xeon Processor 5200, 5400, 7400 Series and Intel Core2 Processor Family (2007)    . . .2-4
2.1.14 The Intel Atom Processor Family (2008)     .  . . . . . .2-5
2.1.15 The Intel Atom Processor Family Based on Silvermont Microarchitecture (2013)     .  .  . .2-5
2.1.16 The Intel Corei7 Processor Family (2008)     .  . . . . .2-5
2.1.17 The Intel Xeon Processor 7500 Series (2010)     .  . . . .2-5
2.1.18 2010 Intel Core Processor Family (2010)     .  . . . . .2-6
2.1.19 The Intel Xeon Processor 5600 Series (2010)     .  . . . .2-6
2.1.20 The Second Generation Intel Core Processor Family (2011)     .  . . . . .2-6
2.1.21 The Third Generation Intel Core Processor Family (2012)     .  .  . . .2-6
2.1.22 The Fourth Generation Intel Core Processor Family (2013)     .  . . . . .2-7
2.2 MORE ON SPECIFIC ADVANCES     .   . .  . . . 2-7
2.2.1 P6 Family Microarchitecture    .   . .  . . . .2-7
2.2.2 Intel NetBurst Microarchitecture     .  .  .  . . . .2-8
2.2.2.1 The Front End Pipeline     .   .  . . . .2-9
2.2.2.2 Out-Of-Order Execution Core    .  .  .  .  . 2-10
2.2.2.3 Retirement Unit     .   .  .  .  . 2-10
2.2.3 Intel Core Microarchitecture    .   . . . . 2-10
2.2.3.1 The Front End      . . . . . . 2-11
2.2.3.2 Execution Core      . . . . . 2-12
2.2.4 Intel Atom Microarchitecture     .  .  .  .  . 2-12
2.2.5 Intel Microarchitecture Code Name Nehalem      .  .  . . . 2-13
2.2.6 Intel Microarchitecture Code Name Sandy Bridge     .  . . . 2-13
2.2.7 SIMD Instructions      . . . . . . 2-14
2.2.8 Intel Hyper-Threading Technology     .   . . . 2-16
2.2.8.1 Some Implementation Notes     .  .  .  .  . 2-17
2.2.9 Multi-Core Technology      . . . . 2-18
2.2.10 Intel 64 Architecture      . . . . 2-20
2.2.11 Intel Virtualization Technology (Intel VT)     .  . . . . 2-20
2.3 INTEL 64 AND IA-32 PROCESSOR GENERATIONS     .  .  . . 2-20
2.4 PROPOSED REMOVAL OF INTEL INSTRUCTION SET ARCHITECTURE AND FEATURES FROM UPCOMING PRODUCTS   . 2-28
2.5 INTEL INSTRUCTION SET ARCHITECTURE AND FEATURES REMOVED     . .  . . 2-28

CHAPTER 3
BASIC EXECUTION ENVIRONMENT
3.1 MODES OF OPERATION     . . . . . 3-1
3.1.1 Intel 64 Architecture     .   .  .  . . .3-1
3.2 OVERVIEW OF THE BASIC EXECUTION ENVIRONMENT      .  . . . 3-2
3.2.1 64-Bit Mode Execution Environment     .   . . . .3-5
3.3 MEMORY ORGANIZATION     .   .  .  . . 3-6
3.3.1 IA-32 Memory Models    .   .  .  . . . .3-7
3.3.2 Paging and Virtual Memory    .   . .  .  . .3-8
3.3.3 Memory Organization in 64-Bit Mode     .  .  . . . . .3-8
3.3.4 Modes of Operation vs. Memory Model     .  .  . . . .3-9
3.3.5 32-Bit and 16-Bit Address and Operand Sizes      .  .  .  . .3-9
3.3.6 Extended Physical Addressing in Protected Mode      .  . . . . .3-9
3.3.7 Address Calculations in 64-Bit Mode     .  .  . . . . 3-10
3.3.7.1 Canonical Addressing     .   .  . . . 3-10
3.4 BASIC PROGRAM EXECUTION REGISTERS     .  . .  .  . 3-10
3.4.1 General-Purpose Registers     .   . .  . . . 3-11
3.4.1.1 General-Purpose Registers in 64-Bit Mode      .  .  . . . 3-12
3.4.2 Segment Registers     .   .  .  .  . 3-13
3.4.2.1 Segment Registers in 64-Bit Mode    .  .  . . . 3-15
3.4.3 EFLAGS Register     . .  . . 3-15
3.4.3.1 Status Flags      . . .  . . 3-16
3.4.3.2 DF Flag     .  . . . 3-17
3.4.3.3 System Flags and IOPL Field    .   . . . . 3-17
3.4.3.4 RFLAGS Register in 64-Bit Mode    .   . . . 3-18
3.5 INSTRUCTION POINTER     .   .  .  . . . 3-18
3.5.1 Instruction Pointer in 64-Bit Mode     .  .  .  . . 3-18
3.6 OPERAND-SIZE AND ADDRESS-SIZE ATTRIBUTES      .  .  . . 3-18
3.6.1 Operand Size and Address Size in 64-Bit Mode      .  .  . . 3-19
3.7 OPERAND ADDRESSING     .   .  .  . . . 3-19
3.7.1 Immediate Operands     .   .  .  . . . 3-20
3.7.2 Register Operands      . . . . . 3-20
3.7.2.1 Register Operands in 64-Bit Mode     .  .  . . . 3-21
3.7.3 Memory Operands      . . . . . 3-21
3.7.3.1 Memory Operands in 64-Bit Mode     .  .  . . . 3-21
3.7.4 Specifying a Segment Selector     .   . . . . 3-21
3.7.4.1 Segmentation in 64-Bit Mode     .  .  .  . . . 3-22
3.7.5 Specifying an Offset     .   .  .  . . . 3-22
3.7.5.1 Specifying an Offset in 64-Bit Mode     .  . .  . . . 3-24
3.7.6 Assembler and Compiler Addressing Modes     .  . . . . 3-24
3.7.7 I/O Port Addressing     .   .  .  .  . 3-24

CHAPTER 4
DATA TYPES
4.1 FUNDAMENTAL DATA TYPES    .   .  . . . 4-1
4.1.1 Alignment of Words, Doublewords, Quadwords, and Double Quadwords    .   .  . . . .4-2
4.2 NUMERIC DATA TYPES      . . . . . 4-2
4.2.1 Integers      . .  .  .  . .4-3
4.2.1.1 Unsigned Integers     .   .  .  . . . .4-3
4.2.1.2 Signed Integers     . . . . . . .4-4
4.2.2 Floating-Point Data Types    .   .  . . . .4-4
4.3 POINTER DATA TYPES      . . . . . 4-6
4.3.1 Pointer Data Types in 64-Bit Mode     .  .  .  . . .4-7
4.4 BIT FIELD DATA TYPE     . . . . . . 4-7
4.5 STRING DATA TYPES      . . . . . . 4-8
4.6 PACKED SIMD DATA TYPES     .   .  . . . . 4-8
4.6.1 64-Bit SIMD Packed Data Types     .   . . . . .4-8
4.6.2 128-Bit Packed SIMD Data Types    .  .  .  .  . .4-8
4.7 BCD AND PACKED BCD INTEGERS    .   .  . . 4-9
4.8 REAL NUMBERS AND FLOATING-POINT FORMATS     .  .  . . 4-11
4.8.1 Real Number System     .   .  .  . . 4-11
4.8.2 Floating-Point Format      . . . . 4-11
4.8.2.1 Normalized Numbers     .   .  . . . 4-13
4.8.2.2 Biased Exponent     .   .  .  . . . 4-13
4.8.3 Real Number and Non-number Encodings     .  .  . . 4-13
4.8.3.1 Signed Zeros      . .  . . 4-14
4.8.3.2 Normalized and Denormalized Finite Numbers      .  . . . 4-14
4.8.3.3 Signed Infinities     .   .  .  .  . 4-15
4.8.3.4 NaNs      . .  .  . . 4-15
4.8.3.5 Operating on SNaNs and QNaNs     .   . . . 4-16
4.8.3.6 Using SNaNs and QNaNs in Applications     .  . . . . 4-16
4.8.3.7 QNaN Floating-Point Indefinite     .  .  .  . . 4-17
4.8.3.8 Half-Precision Floating-Point Operation    .  . . . . . 4-17
4.8.4 Rounding      .  . . . 4-17
4.8.4.1 Rounding Control (RC) Fields     .  .  .  .  . 4-18
4.8.4.2 Truncation with SSE and SSE2 Conversion Instructions     .  .  . . . 4-18
4.9 OVERVIEW OF FLOATING-POINT EXCEPTIONS    .  . . . . . 4-18
4.9.1 Floating-Point Exception Conditions     .  .  . . . . 4-20
4.9.1.1 Invalid Operation Exception (#I)     .   . . . 4-20
4.9.1.2 Denormal Operand Exception (#D)    .  .  . . . 4-20
4.9.1.3 Divide-By-Zero Exception (#Z)     .  .  .  . . 4-20
4.9.1.4 Numeric Overflow Exception (#O)     .  .  . . . 4-21
4.9.1.5 Numeric Underflow Exception (#U)     .  . .  .  . 4-22
4.9.1.6 Inexact-Result (Precision) Exception (#P)      .  .  .  . 4-23
4.9.2 Floating-Point Exception Priority     .  .  .  . . . 4-24
4.9.3 Typical Actions of a Floating-Point Exception Handler      .  . . 4-24

CHAPTER 5
INSTRUCTION SET SUMMARY
5.1 GENERAL-PURPOSE INSTRUCTIONS     .  .  .  .  . 5-3
5.1.1 Data Transfer Instructions     .   . .  .  . .5-3
5.1.2 Binary Arithmetic Instructions    .   .  . . .5-4
5.1.3 Decimal Arithmetic Instructions     .   . . . . .5-4
5.1.4 Logical Instructions      . . . . . .5-4
5.1.5 Shift and Rotate Instructions    .   . .  . . .5-4
5.1.6 Bit and Byte Instructions    .   .  . . . . .5-5
5.1.7 Control Transfer Instructions    .   . .  . . .5-5
5.1.8 String Instructions     . . . . . . .5-6
5.1.9 I/O Instructions     . . .  . . . .5-7
5.1.10 Enter and Leave Instructions    .   . .  . . .5-7
5.1.11 Flag Control (EFLAG) Instructions     .  .  .  .  . .5-7
5.1.12 Segment Register Instructions     .   . . . . . .5-7
5.1.13 Miscellaneous Instructions     .   . .  .  . .5-8
5.1.14 User Mode Extended Sate Save/Restore Instructions     . .  . . . .5-8
5.1.15 Random Number Generator Instructions     .  . .  . . . .5-8
5.1.16 BMI1, BMI2      .  . . . .5-8
5.1.16.1 Detection of VEX-encoded GPR Instructions, LZCNT and TZCNT, PREFETCHW    .  . . . . .5-9
5.2 X87 FPU INSTRUCTIONS     .   .  .  . . . 5-9
5.2.1 x87 FPU Data Transfer Instructions     .   . . . .5-9
5.2.2 x87 FPU Basic Arithmetic Instructions     .  .  . . . .5-9
5.2.3 x87 FPU Comparison Instructions    .  .  .  . . . 5-10
5.2.4 x87 FPU Transcendental Instructions    .  .  . . . 5-11
5.2.5 x87 FPU Load Constants Instructions     .  .  . . . 5-11
5.2.6 x87 FPU Control Instructions     .   .  . . 5-11
5.3 X87 FPU AND SIMD STATE MANAGEMENT INSTRUCTIONS      . . . . . 5-12
5.4 MMX INSTRUCTIONS     . . . . . 5-12
5.4.1 MMX Data Transfer Instructions     .  .  .  .  . 5-12
5.4.2 MMX Conversion Instructions    .   .  . . 5-12
5.4.3 MMX Packed Arithmetic Instructions     .  .  . . . . 5-13
5.4.4 MMX Comparison Instructions     .   . . . . . 5-13
5.4.5 MMX Logical Instructions     .   .  . . . 5-13
5.4.6 MMX Shift and Rotate Instructions     .   . . . 5-13
5.4.7 MMX State Management Instructions     .  .  . . . 5-14
5.5 SSE INSTRUCTIONS      . .  . . 5-14
5.5.1 SSE SIMD Single-Precision Floating-Point Instructions     . .  . . 5-14
5.5.1.1 SSE Data Transfer Instructions     .  .  .  . . 5-14
5.5.1.2 SSE Packed Arithmetic Instructions     .  . .  .  . 5-15
5.5.1.3 SSE Comparison Instructions     .  .  .  .  . 5-15
5.5.1.4 SSE Logical Instructions     .   . .  . . . 5-15
5.5.1.5 SSE Shuffle and Unpack Instructions    .  . .  . . . 5-15
5.5.1.6 SSE Conversion Instructions    .   . . . . 5-16
5.5.2 SSE MXCSR State Management Instructions    .  . . . . 5-16
5.5.3 SSE 64-Bit SIMD Integer Instructions     .  .  . . . 5-16
5.5.4 SSE Cacheability Control, Prefetch, and Instruction Ordering Instructions     . . . 5-16
5.6 SSE2 INSTRUCTIONS     . . . . . . 5-17
5.6.1 SSE2 Packed and Scalar Double-Precision Floating-Point Instructions     . . . . 5-17
5.6.1.1 SSE2 Data Movement Instructions    .  .  . . . 5-17
5.6.1.2 SSE2 Packed Arithmetic Instructions    .  . .  . . . 5-18
5.6.1.3 SSE2 Logical Instructions    .   . .  . . 5-18
5.6.1.4 SSE2 Compare Instructions    .   . . . . . 5-18
5.6.1.5 SSE2 Shuffle and Unpack Instructions     .  .  . . 5-18
5.6.1.6 SSE2 Conversion Instructions     .  .  .  . . . 5-19
5.6.2 SSE2 Packed Single-Precision Floating-Point Instructions     .  .  .  . 5-19
5.6.3 SSE2 128-Bit SIMD Integer Instructions     .  . .  . . . 5-19
5.6.4 SSE2 Cacheability Control and Ordering Instructions      . .  . . . 5-20
5.7 SSE3 INSTRUCTIONS     . . . . . . 5-20
5.7.1 SSE3 x87-FP Integer Conversion Instruction      .  .  .  . 5-20
5.7.2 SSE3 Specialized 128-bit Unaligned Data Load Instruction     .  .  . . . 5-20
5.7.3 SSE3 SIMD Floating-Point Packed ADD/SUB Instructions      . . . . 5-21
5.7.4 SSE3 SIMD Floating-Point Horizontal ADD/SUB Instructions     .  .  . . 5-21
5.7.5 SSE3 SIMD Floating-Point LOAD/MOVE/DUPLICATE Instructions     . .  .  . 5-21
5.7.6 SSE3 Agent Synchronization Instructions     .  .  . . 5-21
5.8 SUPPLEMENTAL STREAMING SIMD EXTENSIONS 3 (SSSE3) INSTRUCTIONS    .   .  . . 5-21
5.8.1 Horizontal Addition/Subtraction     .  .  .  .  . 5-22
5.8.2 Packed Absolute Values    .   .  . . . . 5-22
5.8.3 Multiply and Add Packed Signed and Unsigned Bytes      . .  . . 5-22
5.8.4 Packed Multiply High with Round and Scale     .  . . . . 5-22
5.8.5 Packed Shuffle Bytes     .   .  .  . . 5-23
5.8.6 Packed Sign      . .  . . . 5-23
5.8.7 Packed Align Right      . . . . . 5-23
5.9 SSE4 INSTRUCTIONS     . . . . . . 5-23
5.10 SSE4.1 INSTRUCTIONS     .   .  .  .  . 5-24
5.10.1 Dword Multiply Instructions     .   . .  . . 5-24
5.10.2 Floating-Point Dot Product Instructions     .  . .  . . . 5-24
5.10.3 Streaming Load Hint Instruction     .  .  .  .  . 5-24
5.10.4 Packed Blending Instructions     .   .  . . 5-24
5.10.5 Packed Integer MIN/MAX Instructions    .  .  . . . 5-24
5.10.6 Floating-Point Round Instructions with Selectable Rounding Mode    . .  . . 5-25
5.10.7 Insertion and Extractions from XMM Registers      .  .  . . 5-25
5.10.8 Packed Integer Format Conversions     .  .  . . . . 5-25
5.10.9 Improved Sums of Absolute Differences (SAD) for 4-Byte Blocks     . .  . . . 5-26
5.10.10 Horizontal Search      . . . . . 5-26
5.10.11 Packed Test     . .  . . . 5-26
5.10.12 Packed Qword Equality Comparisons     .  .  . . . 5-26
5.10.13 Dword Packing With Unsigned Saturation     .  .  . . 5-26
5.11 SSE4.2 INSTRUCTION SET     . . . . 5-26
5.11.1 String and Text Processing Instructions     .  . .  . . 5-26
5.11.2 Packed Comparison SIMD integer Instruction      .  .  .  . 5-27
5.12 AESNI AND PCLMULQDQ     .   .  .  . . 5-27
5.13 INTEL ADVANCED VECTOR EXTENSIONS (INTEL AVX)     . .  . . . 5-27
5.14 16-BIT FLOATING-POINT CONVERSION     .  .  . . . . 5-27
5.15 FUSED-MULTIPLY-ADD (FMA)     .   . .  . . . 5-28
5.16 INTEL ADVANCED VECTOR EXTENSIONS 2 (INTEL AVX2)      . . . . 5-28
5.17 INTEL TRANSACTIONAL SYNCHRONIZATION EXTENSIONS (INTEL TSX)    .   .  .  . 5-28
5.18 INTEL SHA EXTENSIONS      . . . . 5-28
5.19 INTEL ADVANCED VECTOR EXTENSIONS 512 (INTEL AVX-512)     .  . . . 5-28
5.20 SYSTEM INSTRUCTIONS    .   .  .  . . . 5-32
5.21 64-BIT MODE INSTRUCTIONS    .   . .  .  . 5-33
5.22 VIRTUAL-MACHINE EXTENSIONS     .   . . . . . 5-34
5.23 SAFER MODE EXTENSIONS    .   .  . . . . 5-34
5.24 INTEL MEMORY PROTECTION EXTENSIONS    .  . .  . . 5-35
5.25 INTEL SOFTWARE GUARD EXTENSIONS    .  .  . . . 5-35

CHAPTER 6
PROCEDURE CALLS, INTERRUPTS, AND EXCEPTIONS
6.1 PROCEDURE CALL TYPES     .   .  .  . . 6-1
6.2 STACKS      .  .  . . 6-1
6.2.1 Setting Up a Stack     . . . . . . .6-2
6.2.2 Stack Alignment      . . .  . . .6-2
6.2.3 Address-Size Attributes for Stack Accesses    .  . . . . . .6-3
6.2.4 Procedure Linking Information     .   . . . . . .6-3
6.2.4.1 Stack-Frame Base Pointer     .   .  . . .6-3
6.2.4.2 Return Instruction Pointer     .   .  . . .6-3
6.2.5 Stack Behavior in 64-Bit Mode     .   . . . . . .6-4
6.3 CALLING PROCEDURES USING CALL AND RET     .  .  . . 6-4
6.3.1 Near CALL and RET Operation    .   .  . . .6-4
6.3.2 Far CALL and RET Operation     .   . .  . . .6-4
6.3.3 Parameter Passing      . . . . . .6-5
6.3.3.1 Passing Parameters Through the General-Purpose Registers     . .  .  . .6-5
6.3.3.2 Passing Parameters on the Stack    .   . . . .6-5
6.3.3.3 Passing Parameters in an Argument List     .  . . . . . .6-6
6.3.4 Saving Procedure State Information     .   . . . .6-6
6.3.5 Calls to Other Privilege Levels     .   .  . . .6-6
6.3.6 CALL and RET Operation Between Privilege Levels      .  . . . .6-7
6.3.7 Branch Functions in 64-Bit Mode     .  .  .  .  . .6-9
6.4 INTERRUPTS AND EXCEPTIONS     .   . .  . . 6-9
6.4.1 Call and Return Operation for Interrupt or Exception Handling Procedures   .   . . . . 6-10
6.4.2 Calls to Interrupt or Exception Handler Tasks      .  .  . . . 6-13
6.4.3 Interrupt and Exception Handling in Real-Address Mode      . . . . 6-13
6.4.4 INT n, INTO, INT3, INT1, and BOUND Instructions      .  . . . . 6-13
6.4.5 Handling Floating-Point Exceptions     .   . . . 6-14
6.4.6 Interrupt and Exception Behavior in 64-Bit Mode     .  . . . . 6-14
6.5 PROCEDURE CALLS FOR BLOCK-STRUCTURED LANGUAGES     . . . . 6-14
6.5.1 ENTER Instruction      . . . . . 6-15
6.5.2 LEAVE Instruction      . . . . . 6-19

CHAPTER 7
PROGRAMMING WITH GENERAL-PURPOSE INSTRUCTIONS
7.1 PROGRAMMING ENVIRONMENT FOR GP INSTRUCTIONS     . .  .  . 7-1
7.2 PROGRAMMING ENVIRONMENT FOR GP INSTRUCTIONS IN 64-BIT MODE    . . . . . 7-1
7.3 SUMMARY OF GP INSTRUCTIONS     .   .  . . 7-2
7.3.1 Data Transfer Instructions     .   . .  .  . .7-2
7.3.1.1 General Data Movement Instructions     .  . .  . . . .7-3
7.3.1.2 Exchange Instructions     .   .  . . . .7-4
7.3.1.3 Exchange Instructions in 64-Bit Mode    .  . .  . . . .7-5
7.3.1.4 Stack Manipulation Instructions    .  .  .  . . . .7-5
7.3.1.5 Stack Manipulation Instructions in 64-Bit Mode     .  . . . . .7-7
7.3.1.6 Type Conversion Instructions     .  .  .  .  . .7-7
7.3.1.7 Type Conversion Instructions in 64-Bit Mode     .  .  . . .7-8
7.3.2 Binary Arithmetic Instructions     .   .  . . .7-8
7.3.2.1 Addition and Subtraction Instructions    .  . .  . . . .7-8
7.3.2.2 Increment and Decrement Instructions    .  . .  . . .7-8
7.3.2.3 Increment and Decrement Instructions in 64-Bit Mode     . . . . .7-8
7.3.2.4 Comparison and Sign Change Instructions     .  . . . . .7-8
7.3.2.5 Multiplication and Division Instructions    .  . .  . . .7-9
7.3.3 Decimal Arithmetic Instructions    .   . . . . . .7-9
7.3.3.1 Packed BCD Adjustment Instructions     .  . .  . . . .7-9
7.3.3.2 Unpacked BCD Adjustment Instructions     .  .  . . .7-9
7.3.4 Decimal Arithmetic Instructions in 64-Bit Mode      .  .  . . 7-10
7.3.5 Logical Instructions     .   .  .  .  . 7-10
7.3.6 Shift and Rotate Instructions     .   .  . . 7-10
7.3.6.1 Shift Instructions     .   .  .  . . . 7-10
7.3.6.2 Double-Shift Instructions    .   . .  . . 7-12
7.3.6.3 Rotate Instructions      . . . . 7-13
7.3.7 Bit and Byte Instructions     .   .  . . . 7-13
7.3.7.1 Bit Test and Modify Instructions     .   . . . 7-14
7.3.7.2 Bit Scan Instructions     .   .  . . . . 7-14
7.3.7.3 Byte Set on Condition Instructions    .  .  . . . 7-14
7.3.7.4 Test Instruction     .   .  .  .  . 7-14
7.3.8 Control Transfer Instructions     .   .  . . 7-14
7.3.8.1 Unconditional Transfer Instructions    .  . .  .  . 7-14
7.3.8.2 Conditional Transfer Instructions     .  .  . . . . 7-15
7.3.8.3 Control Transfer Instructions in 64-Bit Mode     .  . . . 7-17
7.3.8.4 Software Interrupt Instructions     .   . . . 7-17
7.3.8.5 Software Interrupt Instructions in 64-bit Mode and Compatibility Mode   .   . . . . 7-18
7.3.9 String Operations      . . . . . . 7-18
7.3.9.1 String Instructions     .   .  .  . . 7-18
7.3.9.2 Repeated String Operations     .   . . . . 7-19
7.3.9.3 Fast-String Operation     .   .  . . . 7-19
7.3.9.4 String Operations in 64-Bit Mode     .  .  . . . . 7-20
7.3.10 I/O Instructions      . . .  . . 7-20
7.3.11 I/O Instructions in 64-Bit Mode     .   . . . . 7-20
7.3.12 Enter and Leave Instructions     .   .  . . 7-21
7.3.13 Flag Control (EFLAG) Instructions     .  .  .  . . . 7-21
7.3.13.1 Carry and Direction Flag Instructions    .  . .  . . . 7-21
7.3.13.2 EFLAGS Transfer Instructions     .  .  .  . . . 7-21
7.3.13.3 Interrupt Flag Instructions     .   . . . . . 7-22
7.3.14 Flag Control (RFLAG) Instructions in 64-Bit Mode      .  . . . . 7-22
7.3.15 Segment Register Instructions     .   . . . . 7-22
7.3.15.1 Segment-Register Load and Store Instructions      .  . . . 7-22
7.3.15.2 Far Control Transfer Instructions     .  .  . . . . 7-22
7.3.15.3 Software Interrupt Instructions     .   . . . 7-23
7.3.15.4 Load Far Pointer Instructions    .  .  .  .  . 7-23
7.3.16 Miscellaneous Instructions     .   . .  . . . 7-23
7.3.16.1 Address Computation Instruction     .  .  . . . . 7-23
7.3.16.2 Table Lookup Instructions    .   .  . . 7-23
7.3.16.3 Processor Identification Instruction    .  . .  .  . 7-23
7.3.16.4 No-Operation and Undefined Instructions      .  .  .  . 7-23
7.3.17 Random Number Generator Instructions     .  . .  . . 7-24
7.3.17.1 RDRAND      . .  . . . 7-24
7.3.17.2 RDSEED     . .  . . . . 7-24
CHAPTER 8
PROGRAMMING WITH THE X87 FPU
8.1 X87 FPU EXECUTION ENVIRONMENT     .  .  .  . . . 8-1
8.1.1 x87 FPU in 64-Bit Mode and Compatibility Mode     .  . . . .8-1
8.1.2 x87 FPU Data Registers     .   .  . . . . .8-1
8.1.2.1 Parameter Passing With the x87 FPU Register Stack      . . . . . .8-3
8.1.3 x87 FPU Status Register    .   .  . . . . .8-4
8.1.3.1 Top of Stack (TOP) Pointer    .   .  . . .8-4
8.1.3.2 Condition Code Flags     .   .  . . . . .8-4
8.1.3.3 x87 FPU Floating-Point Exception Flags     .  . . . . . .8-5
8.1.3.4 Stack Fault Flag      . . . . . .8-6
8.1.4 Branching and Conditional Moves on Condition Codes     . .  . . . .8-6
8.1.5 x87 FPU Control Word     .   .  .  . . .8-7
8.1.5.1 x87 FPU Floating-Point Exception Mask Bits      .  .  . . .8-7
8.1.5.2 Precision Control Field     .   .  . . . .8-7
8.1.5.3 Rounding Control Field    .   .  . . . .8-8
8.1.6 Infinity Control Flag     . . . . . .8-8
8.1.7 x87 FPU Tag Word      . . . . . .8-8
8.1.8 x87 FPU Instruction and Data (Operand) Pointers      .  . . . . .8-9
8.1.9 Last Instruction Opcode    .   .  . . . . 8-10
8.1.9.1 Fopcode Compatibility Sub-mode     .  .  . . . . 8-10
8.1.10 Saving the x87 FPU¡¯s State with FSTENV/FNSTENV and FSAVE/FNSAVE    . . . 8-11
8.1.11 Saving the x87 FPU¡¯s State with FXSAVE    .  .  . . 8-12
8.2 X87 FPU DATA TYPES     .   .  .  .  . 8-13
8.2.1 Indefinites      . .  . . . . 8-14
8.2.2 Unsupported Double Extended-Precision Floating-Point Encodings and Pseudo-Denormals    .  . . 8-14
8.3 X87 FPU INSTRUCTION SET    .   .  . . . 8-15
8.3.1 Escape (ESC) Instructions     .   . .  .  . 8-15
8.3.2 x87 FPU Instruction Operands     .   . . . . 8-15
8.3.3 Data Transfer Instructions     .   . .  . . . 8-16
8.3.4 Load Constant Instructions    .   . .  . . . 8-17
8.3.5 Basic Arithmetic Instructions     .   .  . . 8-17
8.3.6 Comparison and Classification Instructions     .  . . . . . 8-18
8.3.6.1 Branching on the x87 FPU Condition Codes      .  .  . . 8-20
8.3.7 Trigonometric Instructions     .   . .  . . . 8-20
8.3.8 Approximation of Pi     .   .  .  . . . 8-21
8.3.9 Logarithmic, Exponential, and Scale    .   . . . 8-21
8.3.10 Transcendental Instruction Accuracy     .  .  . . . 8-22
8.3.11 x87 FPU Control Instructions    .   .  . . 8-23
8.3.12 Waiting vs. Non-waiting Instructions    .  .  . . . . 8-24
8.3.13 Unsupported x87 FPU Instructions     .   . . . 8-24
8.4 X87 FPU FLOATING-POINT EXCEPTION HANDLING     .  . . . 8-24
8.4.1 Arithmetic vs. Non-arithmetic Instructions     .  . . . . . 8-25
8.5 X87 FPU FLOATING-POINT EXCEPTION CONDITIONS      .  . . . 8-26
8.5.1 Invalid Operation Exception     .   . .  . . 8-26
8.5.1.1 Stack Overflow or Underflow Exception (#IS)      .  . . . . 8-26
8.5.1.2 Invalid Arithmetic Operand Exception (#IA)      .  .  . . 8-27
8.5.2 Denormal Operand Exception (#D)    .  .  .  . . 8-28
8.5.3 Divide-By-Zero Exception (#Z)     .   . . . . 8-28
8.5.4 Numeric Overflow Exception (#O)     .  .  .  . . 8-29
8.5.5 Numeric Underflow Exception (#U)     .   . . . 8-29
8.5.6 Inexact-Result (Precision) Exception (#P)     .  .  . . 8-30
8.6 X87 FPU EXCEPTION SYNCHRONIZATION    .  . .  .  . 8-31
8.7 HANDLING X87 FPU EXCEPTIONS IN SOFTWARE      .  .  . . . 8-32
8.7.1 Native Mode     . .  . . . 8-32
8.7.2 MS-DOS* Compatibility Sub-mode    .  .  .  . . . 8-32
8.7.3 Handling x87 FPU Exceptions in Software     .  . . . . . 8-33
CHAPTER 9
PROGRAMMING WITH INTEL MMX TECHNOLOGY
9.1 OVERVIEW OF MMX TECHNOLOGY    .   . . . . . 9-1
9.2 THE MMX TECHNOLOGY PROGRAMMING ENVIRONMENT      . .  . . 9-1
9.2.1 MMX Technology in 64-Bit Mode and Compatibility Mode      . . . . .9-2
9.2.2 MMX Registers      . . .  . . . .9-2
9.2.3 MMX Data Types      . .  . . .9-3
9.2.4 Memory Data Formats     .   .  .  . . .9-3
9.2.5 Single Instruction, Multiple Data (SIMD) Execution Model      . . . . . .9-4
9.3 SATURATION AND WRAPAROUND MODES     .  . .  .  . 9-4
9.4 MMX INSTRUCTIONS      . .  . . 9-5
9.4.1 Data Transfer Instructions     .   . .  .  . .9-6
9.4.2 Arithmetic Instructions    .   .  .  . . .9-6
9.4.3 Comparison Instructions     . . . . .9-7
9.4.4 Conversion Instructions      . . . . .9-7
9.4.5 Unpack Instructions     . . . . . .9-7
9.4.6 Logical Instructions      . . . . . .9-7
9.4.7 Shift Instructions      . .  . . .9-8
9.4.8 EMMS Instruction      . .  . . .9-8
9.5 COMPATIBILITY WITH X87 FPU ARCHITECTURE     .  . . . . 9-8
9.5.1 MMX Instructions and the x87 FPU Tag Word      .  .  .  . .9-8
9.6 WRITING APPLICATIONS WITH MMX CODE    .  .  . . . 9-8
9.6.1 Checking for MMX Technology Support     .  . .  .  . .9-8
9.6.2 Transitions Between x87 FPU and MMX Code      .  .  .  . .9-9
9.6.3 Using the EMMS Instruction     .   . .  . . . .9-9
9.6.4 Mixing MMX and x87 FPU Instructions     .  . .  .  . 9-10
9.6.5 Interfacing with MMX Code    .   . .  . . . 9-10
9.6.6 Using MMX Code in a Multitasking Operating System Environment    . .  . . 9-10
9.6.7 Exception Handling in MMX Code     .  .  .  . . . 9-11
9.6.8 Register Mapping      . . . . . . 9-11
9.6.9 Effect of Instruction Prefixes on MMX Instructions      . .  .  . 9-11
CHAPTER 10
PROGRAMMING WITH INTEL STREAMING SIMD EXTENSIONS (INTEL SSE)
10.1 OVERVIEW OF SSE EXTENSIONS    .   .  . . 10-1
10.2 SSE PROGRAMMING ENVIRONMENT     .  .  .  . . . 10-2
10.2.1 SSE in 64-Bit Mode and Compatibility Mode     .  . . . . 10-3
10.2.2 XMM Registers      . . .  . . 10-3
10.2.3 MXCSR Control and Status Register    .   . . . 10-3
10.2.3.1 SIMD Floating-Point Mask and Flag Bits     .  . . . . . 10-4
10.2.3.2 SIMD Floating-Point Rounding Control Field      .  .  . . 10-4
10.2.3.3 Flush-To-Zero      . . . . . . 10-4
10.2.3.4 Denormals-Are-Zeros     .   .  . . . 10-5
10.2.4 Compatibility of SSE Extensions with SSE2/SSE3/MMX and the x87 FPU   .   .  . . 10-5
10.3 SSE DATA TYPES      . . .  . . . 10-5
10.4 SSE INSTRUCTION SET     .   .  .  .  . 10-6
10.4.1 SSE Packed and Scalar Floating-Point Instructions      .  . . . 10-6
10.4.1.1 SSE Data Movement Instructions     .  .  . . . . 10-7
10.4.1.2 SSE Arithmetic Instructions     .   . . . . 10-8
10.4.2 SSE Logical Instructions     .   .  . . . . 10-9
10.4.2.1 SSE Comparison Instructions     .  .  .  .  . 10-9
10.4.2.2 SSE Shuffle and Unpack Instructions    .  . .  . . . 10-9
10.4.3 SSE Conversion Instructions     .   .  . . 10-11
10.4.4 SSE 64-Bit SIMD Integer Instructions     .  . .  .  . 10-11
10.4.5 MXCSR State Management Instructions    .  . .  . . 10-12
10.4.6 Cacheability Control, Prefetch, and Memory Ordering Instructions     .  . . 10-12
10.4.6.1 Cacheability Control Instructions     .  .  . . . 10-12
10.4.6.2 Caching of Temporal vs. Non-Temporal Data      .  . . . . 10-12
10.4.6.3 PREFETCHh Instructions     .   .  . . 10-13
10.4.6.4 SFENCE Instruction     .   .  . . . . 10-14
10.5 FXSAVE AND FXRSTOR INSTRUCTIONS    .  .  . . . 10-14
10.5.1 FXSAVE Area      . . .  . . 10-14
10.5.1.1 x87 State     . . .  . . . 10-15
10.5.1.2 SSE State      . . .  . . . 10-16
10.5.2 Operation of FXSAVE      . . . . 10-16
10.5.3 Operation of FXRSTOR     .   .  . . . 10-17
10.6 HANDLING SSE INSTRUCTION EXCEPTIONS     .  .  . . 10-17
10.7 WRITING APPLICATIONS WITH THE SSE EXTENSIONS     . .  .  . 10-17
CHAPTER 11
PROGRAMMING WITH INTEL STREAMING SIMD EXTENSIONS 2 (INTEL SSE2)
11.1 OVERVIEW OF SSE2 EXTENSIONS     .   . . . . 11-1
11.2 SSE2 PROGRAMMING ENVIRONMENT     .  .  .  . . 11-2
11.2.1 SSE2 in 64-Bit Mode and Compatibility Mode     .  .  .  . 11-3
11.2.2 Compatibility of SSE2 Extensions with SSE, MMX Technology and x87 FPU Programming Environment    . . 11-3
11.2.3 Denormals-Are-Zeros Flag     .   . .  . . . 11-3
11.3 SSE2 DATA TYPES     . . .  . . 11-3
11.4 SSE2 INSTRUCTIONS      . . . . . 11-4
11.4.1 Packed and Scalar Double-Precision Floating-Point Instructions     . .  .  . 11-4
11.4.1.1 Data Movement Instructions     .  .  .  .  . 11-5
11.4.1.2 SSE2 Arithmetic Instructions     .  .  .  .  . 11-6
11.4.1.3 SSE2 Logical Instructions     .   .  . . 11-7
11.4.1.4 SSE2 Comparison Instructions    .  .  .  . . . 11-7
11.4.1.5 SSE2 Shuffle and Unpack Instructions     .  .  . . 11-7
11.4.1.6 SSE2 Conversion Instructions     .  .  .  . . . 11-9
11.4.2 SSE2 64-Bit and 128-Bit SIMD Integer Instructions      . .  . . . 11-10
11.4.3 128-Bit SIMD Integer Instruction Extensions      .  .  . . . 11-11
11.4.4 Cacheability Control and Memory Ordering Instructions      . . . . 11-12
11.4.4.1 FLUSH Cache Line      . . . . 11-12
11.4.4.2 Cacheability Control Instructions     .  .  . . . 11-12
11.4.4.3 Memory Ordering Instructions    .  .  .  . . 11-12
11.4.4.4 Pause     .  . . . 11-12
11.4.5 Branch Hints      . . .  . . . 11-13
11.5 SSE, SSE2, AND SSE3 EXCEPTIONS     .  .  .  . . . 11-13
11.5.1 SIMD Floating-Point Exceptions     .  .  .  . . . 11-13
11.5.2 SIMD Floating-Point Exception Conditions     .  . . . . . 11-14
11.5.2.1 Invalid Operation Exception (#I)     .  .  . . . . 11-14
11.5.2.2 Denormal-Operand Exception (#D)     .  . .  . . . 11-15
11.5.2.3 Divide-By-Zero Exception (#Z)     .   . . . 11-15
11.5.2.4 Numeric Overflow Exception (#O)     .  . .  .  . 11-15
11.5.2.5 Numeric Underflow Exception (#U)     .  . .  . . . 11-16
11.5.2.6 Inexact-Result (Precision) Exception (#P)      .  .  . . . 11-16
11.5.3 Generating SIMD Floating-Point Exceptions      .  .  .  . 11-16
11.5.3.1 Handling Masked Exceptions     .  .  .  . . . 11-16
11.5.3.2 Handling Unmasked Exceptions     .  .  . . . . 11-17
11.5.3.3 Handling Combinations of Masked and Unmasked Exceptions     . .  . . 11-18
11.5.4 Handling SIMD Floating-Point Exceptions in Software     .  . . 11-18
11.5.5 Interaction of SIMD and x87 FPU Floating-Point Exceptions     . . . 11-18
11.6 WRITING APPLICATIONS WITH SSE/SSE2 EXTENSIONS      . .  . . 11-19
11.6.1 General Guidelines for Using SSE/SSE2 Extensions      . .  . . . 11-19
11.6.2 Checking for SSE/SSE2 Support     .  .  .  . . . 11-19
11.6.3 Checking for the DAZ Flag in the MXCSR Register      . .  .  . 11-20
11.6.4 Initialization of SSE/SSE2 Extensions     .  . .  .  . 11-20
11.6.5 Saving and Restoring the SSE/SSE2 State    .  . . . . . 11-20
11.6.6 Guidelines for Writing to the MXCSR Register      .  .  . . 11-21
11.6.7 Interaction of SSE/SSE2 Instructions with x87 FPU and MMX Instructions    .   . . . 11-21
11.6.8 Compatibility of SIMD and x87 FPU Floating-Point Data Types     . .  .  . 11-22
11.6.9 Mixing Packed and Scalar Floating-Point and 128-Bit SIMD Integer Instructions and Data    .  . . . 11-22
11.6.10 Interfacing with SSE/SSE2 Procedures and Functions      .  . . 11-23
11.6.10.1 Passing Parameters in XMM Registers     .  . . . . . 11-23
11.6.10.2 Saving XMM Register State on a Procedure or Function Call     . .  .  . 11-23
11.6.10.3 Caller-Save Recommendation for Procedure and Function Calls    .  . . 11-24
11.6.11 Updating Existing MMX Technology Routines Using 128-Bit SIMD Integer Instructions    . . . . 11-24
11.6.12 Branching on Arithmetic Operations     .  .  . . . 11-24
11.6.13 Cacheability Hint Instructions    .   . . . . . 11-25
11.6.14 Effect of Instruction Prefixes on the SSE/SSE2 Instructions     . . . 11-25
CHAPTER 12
PROGRAMMING WITH INTEL SSE3, SSSE3, INTEL SSE4 AND INTEL AESNI
12.1 PROGRAMMING ENVIRONMENT AND DATA TYPES     .  .  . . 12-1
12.1.1 SSE3, SSSE3, SSE4 in 64-Bit Mode and Compatibility Mode    .  .  . . . 12-1
12.1.2 Compatibility of SSE3/SSSE3 with MMX Technology, the x87 FPU Environment, and SSE/SSE2 Extensions   . . 12-1
12.1.3 Horizontal and Asymmetric Processing    .  . .  .  . 12-1
12.2 OVERVIEW OF SSE3 INSTRUCTIONS     .  .  .  . . . 12-2
12.3 SSE3 INSTRUCTIONS     . . . . . . 12-2
12.3.1 x87 FPU Instruction for Integer Conversion     .  . . . . 12-3
12.3.2 SIMD Integer Instruction for Specialized 128-bit Unaligned Data Load    .   .  .  . 12-3
12.3.3 SIMD Floating-Point Instructions That Enhance LOAD/MOVE/DUPLICATE Performance   .  . . 12-3
12.3.4 SIMD Floating-Point Instructions Provide Packed Addition/Subtraction   .   .  .  . 12-4
12.3.5 SIMD Floating-Point Instructions Provide Horizontal Addition/Subtraction    . . . 12-4
12.3.6 Two Thread Synchronization Instructions     .  .  . . 12-5
12.4 WRITING APPLICATIONS WITH SSE3 EXTENSIONS      .  .  . . 12-5
12.4.1 Guidelines for Using SSE3 Extensions     .  .  . . . 12-5
12.4.2 Checking for SSE3 Support     .   . .  . . . 12-5
12.4.3 Enable FTZ and DAZ for SIMD Floating-Point Computation     .  .  . . . 12-6
12.4.4 Programming SSE3 with SSE/SSE2 Extensions      .  .  . . 12-6
12.5 OVERVIEW OF SSSE3 INSTRUCTIONS     .  .  .  . . 12-6
12.6 SSSE3 INSTRUCTIONS     . . . . . 12-6
12.6.1 Horizontal Addition/Subtraction     .  .  .  .  . 12-7
12.6.2 Packed Absolute Values    .   .  . . . . 12-7
12.6.3 Multiply and Add Packed Signed and Unsigned Bytes      . .  . . 12-8
12.6.4 Packed Multiply High with Round and Scale     .  . . . . 12-8
12.6.5 Packed Shuffle Bytes     .   .  .  . . 12-8
12.6.6 Packed Sign      . .  . . . 12-8
12.6.7 Packed Align Right      . . . . . 12-8
12.7 WRITING APPLICATIONS WITH SSSE3 EXTENSIONS     .  . . . 12-9
12.7.1 Guidelines for Using SSSE3 Extensions    .  . .  .  . 12-9
12.7.2 Checking for SSSE3 Support     .   . .  . . 12-9
12.8 SSE3/SSSE3 AND SSE4 EXCEPTIONS    .  .  .  . . . 12-9
12.8.1 Device Not Available (DNA) Exceptions    .  . .  .  . 12-9
12.8.2 Numeric Error flag and IGNNE#     .   . . . . 12-9
12.8.3 Emulation      . .  . . . . 12-10
12.8.4 IEEE 754 Compliance of SSE4.1 Floating-Point Instructions    .  .  . . 12-10
12.9 SSE4 OVERVIEW     . . .  . . 12-10
12.10 SSE4.1 INSTRUCTION SET     .   .  . . . 12-11
12.10.1 Dword Multiply Instructions     .   .  . . 12-11
12.10.2 Floating-Point Dot Product Instructions     .  . .  . . 12-11
12.10.3 Streaming Load Hint Instruction     .  .  .  . . . 12-12
12.10.4 Packed Blending Instructions     .   . . . . . 12-14
12.10.5 Packed Integer MIN/MAX Instructions    .  . .  .  . 12-14
12.10.6 Floating-Point Round Instructions with Selectable Rounding Mode    .  . . 12-14
12.10.7 Insertion and Extractions from XMM Registers     .  . . . 12-15
12.10.8 Packed Integer Format Conversions     .  .  . . . 12-15
12.10.9 Improved Sums of Absolute Differences (SAD) for 4-Byte Blocks     . .  . . 12-16
12.10.10 Horizontal Search     .   .  .  .  . 12-16
12.10.11 Packed Test     . . .  .  . 12-17
12.10.12 Packed Qword Equality Comparisons     .  . .  .  . 12-17
12.10.13 Dword Packing With Unsigned Saturation     .  . . . . . 12-17
12.11 SSE4.2 INSTRUCTION SET    .   .  . . . . 12-17
12.11.1 String and Text Processing Instructions     .  .  . . 12-17
12.11.1.1 Memory Operand Alignment     .  .  .  . . . 12-18
12.11.2 Packed Comparison SIMD Integer Instruction      .  .  . . . 12-18
12.12 WRITING APPLICATIONS WITH SSE4 EXTENSIONS     .  . . . 12-18
12.12.1 Guidelines for Using SSE4 Extensions    .  . .  .  . 12-18
12.12.2 Checking for SSE4.1 Support     .   . . . . . 12-19
12.12.3 Checking for SSE4.2 Support     .   . . . . . 12-19
12.13 AESNI OVERVIEW     . . .  . . 12-19
12.13.1 Little-Endian Architecture and Big-Endian Specification (FIPS 197)     . . . . . 12-19
12.13.1.1 AES Data Structure in Intel 64 Architecture    .  . . . 12-20
12.13.2 AES Transformations and Functions     .  .  . . . 12-21
12.13.3 PCLMULQDQ      . . .  . . . 12-24
12.13.4 Checking for AESNI Support     .   .  . . 12-25
CHAPTER 13
MANAGING STATE USING THE XSAVE FEATURE SET
13.1 XSAVE-SUPPORTED FEATURES AND STATE-COMPONENT BITMAPS    . .  . . . 13-1
13.2 ENUMERATION OF CPU SUPPORT FOR XSAVE INSTRUCTIONS AND XSAVE-SUPPORTED FEATURES   .   . . 13-3
13.3 ENABLING THE XSAVE FEATURE SET AND XSAVE-ENABLED FEATURES    . . . . 13-4
13.4 XSAVE AREA      .  . . . 13-6
13.4.1 Legacy Region of an XSAVE Area     .  .  .  . . 13-6
13.4.2 XSAVE Header      . . .  . . 13-7
13.4.3 Extended Region of an XSAVE Area     .  .  . . . . 13-8
13.5 XSAVE-MANAGED STATE      . . . . 13-8
13.5.1 x87 State      .  . . . 13-9
13.5.2 SSE State      .  . . . 13-9
13.5.3 AVX State      . .  . . . 13-10
13.5.4 MPX State      . .  . . . 13-10
13.5.5 AVX-512 State     . .  . . 13-11
13.5.6 PT State      .  . . . 13-12
13.5.7 PKRU State      . . .  .  . 13-12
13.5.8 HDC State     . .  . . . . 13-13
13.6 PROCESSOR TRACKING OF XSAVE-MANAGED STATE      . .  .  . 13-13
13.7 OPERATION OF XSAVE    .   .  .  . . . 13-14
13.8 OPERATION OF XRSTOR      . . . . 13-15
13.8.1 Standard Form of XRSTOR     .   . .  . . 13-15
13.8.2 Compacted Form of XRSTOR     .   . . . . . 13-16
13.8.3 XRSTOR and the Init and Modified Optimizations      .  . . . 13-16
13.9 OPERATION OF XSAVEOPT     .   . .  .  . 13-17
13.10 OPERATION OF XSAVEC      . . . . 13-18
13.11 OPERATION OF XSAVES      . . . . 13-19
13.12 OPERATION OF XRSTORS     .   .  . . . . 13-20
13.13 MEMORY ACCESSES BY THE XSAVE FEATURE SET      .  . . . . 13-21
CHAPTER 14
PROGRAMMING WITH AVX, FMA AND AVX2
14.1 INTEL AVX OVERVIEW     .   .  .  .  . 14-1
14.1.1 256-Bit Wide SIMD Register Support     .  .  . . . 14-1
14.1.2 Instruction Syntax Enhancements     .  .  .  . . 14-2
14.1.3 VEX Prefix Instruction Encoding Support     .  .  . . 14-2
14.2 FUNCTIONAL OVERVIEW    .   .  .  . . 14-3
14.2.1 256-bit Floating-Point Arithmetic Processing Enhancements      . . . 14-9
14.2.2 256-bit Non-Arithmetic Instruction Enhancements      . .  .  . 14-9
14.2.3 Arithmetic Primitives for 128-bit Vector and Scalar processing    . .  .  . 14-11
14.2.4 Non-Arithmetic Primitives for 128-bit Vector and Scalar Processing     . . . . 14-13
14.3 DETECTION OF AVX INSTRUCTIONS     .   . . . 14-15
14.3.1 Detection of VEX-Encoded AES and VPCLMULQDQ      . .  . . . 14-17
14.4 HALF-PRECISION FLOATING-POINT CONVERSION    .  . . . 14-18
14.4.1 Detection of F16C Instructions     .  .  .  .  . 14-20
14.5 FUSED-MULTIPLY-ADD (FMA) EXTENSIONS    .  .  . . 14-21
14.5.1 FMA Instruction Operand Order and Arithmetic Behavior    .  .  .  . 14-22
14.5.2 Fused-Multiply-ADD (FMA) Numeric Behavior      .  .  . . . 14-22
14.5.3 Detection of FMA      . . . . . 14-24
14.6 OVERVIEW OF INTEL ADVANCED VECTOR EXTENSIONS 2 (INTEL AVX2)     . . . 14-25
14.6.1 AVX2 and 256-bit Vector Integer Processing      .  .  . . 14-25
14.7 PROMOTED VECTOR INTEGER INSTRUCTIONS IN AVX2      .  . . 14-26
14.7.1 Detection of AVX2    .   .  .  .  . 14-31
14.8 ACCESSING YMM REGISTERS     .   . .  . . 14-32
14.9 MEMORY ALIGNMENT     .   .  .  . . . 14-32
14.10 SIMD FLOATING-POINT EXCEPTIONS     .   . . . 14-34
14.11 EMULATION      . .  . . . . 14-34
14.12 WRITING AVX FLOATING-POINT EXCEPTION HANDLERS      . . . . . 14-34
14.13 GENERAL PURPOSE INSTRUCTION SET ENHANCEMENTS     . . . . . 14-35
CHAPTER 15
PROGRAMMING WITH INTEL AVX-512
15.1 OVERVIEW      . .  .  . . . 15-1
15.1.1 512-Bit Wide SIMD Register Support    .  .  . . . . 15-1
15.1.2 32 SIMD Register Support    .   . .  .  . 15-1
15.1.3 Eight Opmask Register Support    .   . . . . 15-1
15.1.4 Instruction Syntax Enhancement     .  .  .  . . . 15-2
15.1.5 EVEX Instruction Encoding Support     .   . . . 15-3
15.2 DETECTION OF AVX-512 FOUNDATION INSTRUCTIONS      . .  . . . 15-3
15.2.1 Additional 512-bit Instruction Extensions of the Intel AVX-512 Family    .   .  . . . 15-4
15.3 DETECTION OF 512-BIT INSTRUCTION GROUPS OF INTEL AVX-512 FAMILY    . . . 15-5
15.4 DETECTION OF INTEL AVX-512 INSTRUCTION GROUPS OPERATING AT 256 AND 128-BIT VECTOR LENGTHS   . . 15-6
15.5 ACCESSING XMM, YMM AND ZMM REGISTERS    .  .  . . 15-8
15.6 ENHANCED VECTOR PROGRAMMING ENVIRONMENT USING EVEX ENCODING    .   . . . . 15-8
15.6.1 OPMASK Register to Predicate Vector Data Processing      . . . . . 15-9
15.6.1.1 Opmask Register K0     .   .  . . . . 15-9
15.6.1.2 Example of Opmask Usages     .  .  .  .  . 15-10
15.6.2 OpMask Instructions     .   .  .  . . 15-11
15.6.3 Broadcast      . .  . . . . 15-11
15.6.4 Static Rounding Mode and Suppress All Exceptions      . .  . . . 15-12
15.6.5 Compressed Disp8*N Encoding     .  .  .  .  . 15-13
15.7 MEMORY ALIGNMENT     .   .  .  . . . 15-13
15.8 SIMD FLOATING-POINT EXCEPTIONS     .   . . . 15-14
15.9 INSTRUCTION EXCEPTION SPECIFICATION    .  . .  . . 15-15
15.10 EMULATION      . .  . . . . 15-15
15.11 WRITING FLOATING-POINT EXCEPTION HANDLERS      .  . . . 15-15
CHAPTER 16
PROGRAMMING WITH INTEL TRANSACTIONAL SYNCHRONIZATION EXTENSIONS
16.1 OVERVIEW      . .  .  . . . 16-1
16.2 INTEL TRANSACTIONAL SYNCHRONIZATION EXTENSIONS      . . . . 16-1
16.2.1 HLE Software Interface     .   .  . . . . 16-2
16.2.2 RTM Software Interface     .   .  . . . 16-3
16.3 INTEL TSX APPLICATION PROGRAMMING MODEL      .  .  . . 16-3
16.3.1 Detection of Transactional Synchronization Support      . .  . . . 16-3
16.3.1.1 Detection of HLE Support     .   .  . . 16-3
16.3.1.2 Detection of RTM Support     .   . . . . . 16-3
16.3.1.3 Detection of XTEST Instruction     .   . . . 16-3
16.3.2 Querying Transactional Execution Status     .  .  . . 16-4
16.3.3 Requirements for HLE Locks     .   .  . . 16-4
16.3.4 Transactional Nesting      . . . . 16-4
16.3.4.1 HLE Nesting and Elision     .   . .  . . . 16-4
16.3.4.2 RTM Nesting      . .  . . 16-5
16.3.4.3 Nesting HLE and RTM    .   .  . . . 16-5
16.3.5 RTM Abort Status Definition     .   .  . . 16-5
16.3.6 RTM Memory Ordering     . . . . 16-5
16.3.7 RTM-Enabled Debugger Support    .  .  .  .  . 16-6
16.3.8 Programming Considerations     .   .  . . 16-6
16.3.8.1 Instruction Based Considerations     .  .  . . . . 16-6
16.3.8.2 Runtime Considerations    .   . .  . . . 16-7
CHAPTER 17
INTEL MEMORY PROTECTION EXTENSIONS
17.1 INTEL MEMORY PROTECTION EXTENSIONS (INTEL MPX)      . . . . . 17-1
17.2 INTRODUCTION     . .  . . . 17-1
17.3 INTEL MPX PROGRAMMING ENVIRONMENT     .  . .  . . 17-1
17.3.1 Detection and Enumeration of Intel MPX Interfaces      . .  . . . 17-2
17.3.2 Bounds Registers     . . . . . . 17-2
17.3.3 Configuration and Status Registers    .   . . . 17-3
17.3.4 Read and Write of IA32_BNDCFGS    .  .  .  . . 17-4
17.4 INTEL MPX INSTRUCTION SUMMARY     .  .  .  . . 17-4
17.4.1 Instruction Encoding     .   .  .  . . . 17-5
17.4.2 Usage and Examples    .   .  .  . . . 17-5
17.4.3 Loading and Storing Bounds in Memory     .  . .  . . . 17-6
17.4.3.1 BNDLDX and BNDSTX in 64-Bit Mode    .  . .  . . 17-7
17.4.3.2 BNDLDX and BNDSTX Outside 64-Bit Mode      .  .  . . 17-8
17.5 INTERACTIONS WITH INTEL MPX     .   . . . . . 17-9
17.5.1 Intel MPX and Operating Modes     .  .  .  .  . 17-9
17.5.2 Intel MPX Support for Pointer Operations with Branching    .  .  . . . 17-10
17.5.3 CALL, RET, JMP and All Jcc     .   . .  . . . 17-10
17.5.4 BOUND Instruction and Intel MPX     .   . . . 17-11
17.5.5 Programming Considerations     .   . . . . . 17-11
17.5.6 Intel MPX and System Management Mode     .  . . . . 17-11
17.5.7 Support of Intel MPX in VMCS     .   . . . . 17-11
17.5.8 Support of Intel MPX in Intel TSX    .  .  .  . . 17-12
CHAPTER 18
INPUT/OUTPUT
18.1 I/O PORT ADDRESSING    .   .  .  .  . 18-1
18.2 I/O PORT HARDWARE     . . . . . 18-1
18.3 I/O ADDRESS SPACE      . . . . . . 18-1
18.3.1 Memory-Mapped I/O     .   .  .  . . . 18-2
18.4 I/O INSTRUCTIONS     . . .  . . 18-3
18.5 PROTECTED-MODE I/O     .   .  .  .  . 18-3
18.5.1 I/O Privilege Level      . . . . . 18-3
18.5.2 I/O Permission Bit Map      . . . . 18-4
18.6 ORDERING I/O      . .  . . . . 18-5
CHAPTER 19
PROCESSOR IDENTIFICATION AND FEATURE DETERMINATION
19.1 USING THE CPUID INSTRUCTION    .   .  . . 19-1
19.1.1 Notes on Where to Start     .   .  . . . 19-1
19.1.2 Identification of Earlier IA-32 Processors     .  .  . . 19-1