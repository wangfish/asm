第 1 章
关于本手册
1.1 英特尔 64 和 IA-32 处理器涵盖在此手册中      . . .  .  . .1-1
1.2 第 1 卷概述：基本体系结构     .   .  .  .  . .1-4
1.3 表示惯例      . . .  . . .1-5
1.3.1 位和字节顺序       . . .  . . .1-5
1.3.2 保留位和软件兼容性     .   .  .  .  . ..1-6
1.3.2.1 指令操作     .   . .  .  . .1-6
1.3.3 十六进制和二进制数字     .   .  .  . . .1-7
1.3.4 细分地址     .   .  . . . . .1-7
1.3.5 CPUID、CR 和 MSR 值的新语法      . .  . . . .1-7
1.3.6 例外情况      .   . .  . . .1-8
1.4 相关文献      . . .  . . . ..1-9
第 2 章
英特尔 64 和 IA-32 架构
2.1 《英特尔 64 和 IA-32 架构》 的简要历史     .   .  .  .  . .2-1
2.1.1 16 位处理器和分段 （1978）     .   .  . . .2-1
2.1.2 英特尔 286 处理器 （1982）      .  .  .  .  . .2-1
2.1.3 英特尔386处理器（1985年）      .  .  .  . . .2-1
2.1.4 英特尔486处理器（1989年）      .  .  .  . . .2-1
2.1.5 英特尔奔腾处理器 （1993     .  . . . .2-2
2.1.6 P6处理器系列（1995-1999）     .   . . . . . ..2-2
2.1.7 英特尔奔腾4处理器系列（2000-2006）      . . . . . . .2-3
2.1.8 英特尔至强处理器 （2001- 2007）      . .  . . ..2-3
2.1.9 英特尔奔腾 M 处理器 （2003-2006）      . .  . . .2-3
2.1.10 英特尔奔腾处理器极端版 （2005）      . . .  . . .2-4
2.1.11 英特尔酷睿双核和英特尔酷睿独唱处理器 （2006-2007）     .  . .  . . . .2-4
2.1.12 英特尔至强处理器 5100、5300 系列和英特尔酷睿 2 处理器系列 （2006）      .  .  .  . .2-4
2.1.13 英特尔至强处理器 5200、5400、7400 系列和英特尔酷睿2 处理器系列 （2007）    . . . .2-4
2.1.14 英特尔凌动处理器系列 （2008）     .   . .  . . . .2-5
2.1.15 基于 Silvermont 微架构的英特尔凌动处理器系列 （2013）     .  .  .  . . . .2-5
2.1.16 英特尔 Corei7 处理器系列 （2008）     .   . .  . . .2-5
2.1.17 英特尔至强处理器 7500 系列 （2010）      . . . . . . .2-5
2.1.18 2010 英特尔核心处理器系列 （2010）      . . . . . . .2-6
2.1.19 英特尔至强处理器 5600 系列 （2010）      . . . . . . .2-6
2.1.20 第二代英特尔核心处理器系列 （2011）     .   . . . . . .2-6
2.1.21 第三代英特尔核心处理器系列 （2012）     .   .  . . .2-6
2.1.22 第四代英特尔核心处理器系列 （2013）     .   . . . . . .2-7
2.2 更多有关具体进展的      . . . . . .2-7
2.2.1 P6 家庭微结构     .   .  .  .  . ..2-7
2.2.2 英特尔 NetBurst 微架构      . . . . . .2-8
2.2.2.1 前端管道     .   .  .  .  . .2-9
2.2.2.2 订单执行核心      . . . . . .2-10
2.2.2.3 退休股     .   .  . . . .2-10
2.2.3 英特尔核心微架构      . . . . . . .2-10
2.2.3.1 前端      .  . . . . .2-11
2.2.3.2 执行核心     .   .  .  .  . ..2-12
2.2.4 英特尔凌动微架构     .   .  .  .  . .2-12
2.2.5 英特尔微架构代码名称 Nehalem      . . . . .2-13
2.2.6 英特尔微架构代码名称桑迪桥     .   .  .  . . .2-13
2.2.7 SIMD 指令     .   .  . . . .2-14
2.2.8 英特尔超线程技术      . . . . . .2-16
2.2.8.1 一些实施说明     .   .  .  . . .2-17
2.2.9 多核技术      . . . . . .2-18
2.2.2.10 英特尔 64 架构      .  .  . . . .2-20
2.2.11 英特尔虚拟化技术 （英特尔 VT）     .   .  . . . .2-20
2.3 英特尔 64 和 IA-32 处理器 -      . .  . . . .2-20
2.4 建议从即将推出的产品中删除英特尔指令集体系结构和功能 . . .2-28
2.5 英特尔指令集体系结构和功能被删除     .   .  .  . . . .2-28
第 3 章
基本执行环境
3.1 操作模式     .   .  .  .  . ..3-1
3.1.1 英特尔 64 架构       . . .  . . . .3-1
3.2 基本执行环境概述     .   .  .  .  . .3-2
3.2.1 64-Bit 模式执行环境     .   .  .  . . .3-5
3.3 记忆组织      . . .  . . . .3-6
3.3.1 IA-32 内存模型     .   .  .  . . . .3-7
3.3.2 分页和虚拟内存      . .  .  . . . .3-8
3.3.3 内存组织采用64位模式     .   .  .  . . . .3-8
3.3.4 操作模式与内存模型     .   .  .  . . .3-9
3.3.5 32 位和 16 位地址和操作码大小     .   . .  . . . .3-9
3.3.6 在受保护模式下扩展物理寻址      . .  .  . . ..3-9
3.3.7 64 位模式下的地址计算     .   .  .  . . .3-10
3.3.7.1 规范性称呼     .   .  .  . . .3-10
3.4 基本程序执行登记程序     .  . . . . . .3-10
3.4.1 通用注册     . . . . . . .3-11
3.4.1.1 64 位模式下的通用寄存器      . .  . . . . .3-12
3.4.2 分段注册    .   . .  .  . .3-13
3.4.2.1 64 位模式下的分段寄存器     .   . .  .  . .3-15
3.4.3 EFLAGS 注册     .   .  . . . .3-15
3.4.3.1 状态标志       . . .  . . .3-16
3.4.3.2 DF 标志。      . . .  . . .3-17
3.4.3.3 系统标志和 IOPL 字段      .  . . . .3-17
3.4.3.4 RFLAGS 以 64 位模式注册     .   . .  .  . .3-18
3.5 指令指针      . . .  . . . .3-18
3.5.1 64 位模式下的指令指针      . .  .  . . . .3-18
3.6 操作方式大小和地址大小属性     .   .  .  . . . .3-18
3.6.1 在 64 位模式下的操作数大小和地址大小      . . .  . . . .3-19
3.7 操作处理      . . . . . . .3-19
3.7.1 即时操作     .   .  .  .  . .3-20
3.7.2 登记操作    .   .  .  . . . ..3-20
3.7.2.1 以64位模式注册操作数     .   .  . . . .3-21
3.7.3 内存操作      . . . . . ..3-21
3.7.3.1 64 位模式下的内存操作数      . .  . . . .3-21
3.7.4 指定段选择器     .   .  .  . . . .3-21
3.7.4.1 在64位模式下的分段    .   . .  .  . ..3-22
3.7.5 指定偏移量     .   .  . . . .3-22
3.7.5.1 在64位模式下指定偏移     .   .  . . . . .3-24
3.7.6 汇编器和编译器寻址模式      . . . . .3-24
3.7.7 I/O 端口地址     .   .  .  . . .3-24

第四章
数据类型
4.1 基本数据类型 。  . . . .4-1
4.1.1 单词、双字、四字和双四字的对齐。  . . . . .4-2
4.2 数字数据类型 . . . .4-2
4.2.1 整数 .. . . ..4-3
4.2.1.1 无符号整数 .  . . . . . .4-3
4.2.1.2 已签名整数 . . . . . .4-4
4.2.2 浮点数据类型 。  . . . . .4-4
4.3 指针数据类型 . . . . .4-6
4.3.1 64 位模式下的指针数据类型 。 . . . . .4-7
4.4 位字段数据类型 . . . . . . .4-7
4.5 字符串数据类型 . . . . .4-8
4.6 包装的 SIMD 数据类型 .  . . . . .4-8
4.6.1 64 位 SIMD 打包数据类型 .  . . . . .4-8
4.6.2 128 位打包 SIMD 数据类型 . . . . ..4-8
4.7 BCD 和包装 BCD INTEGERS .  . ..4-9
4.8 实数和浮点格式。 . ..4-11
4.8.1 实数系统 .  . . ..4-11
4.8.2 浮点格式 . . . .4-11
4.8.2.1 标准化数字 .  . . . .4-13
4.8.2.2 偏指数 .  . . . . .4-13
4.8.3 实数和非数字编码。 . ..4-13
4.8.3.1 已签名零 。. ..4-14
4.8.3.2 规范化和去规范化有限数。 . . .4-14
4.8.3.3 已签名无穷大 .  . . . .4-15
4.8.3.4 NaNs .. . ..4-15
4.8.3.5 在 SNAN 和 QNAN 上运行 。  . . .4-16
4.8.3.6 应用程序中使用 SNAN 和 QNAN 。 . . . .4-16
4.8.3.7 QNaN 浮点不确定 . . . ..4-17
4.8.3.8 半精度浮点操作 . . . . . .4-17
4.8.4 舍入 . . . .4-17
4.8.4.1 舍入控制 （RC） 字段 。 . . . .4-18
4.8.4.2 与 SSE 和 SSE2 转换指令的截断 。 . . . .4-18
4.9 浮动点异常的概述 。 . . . . .4-18
4.9.1 浮点异常条件 . . . . . .4-20
4.9.1.1 无效操作异常 （#I） 。  . . .4-20
4.9.1.2 非正常操作异常 （#D） . . . . .4-20
4.9.1.3 除零例外 （#Z） . . . ..4-20
4.9.1.4 数字溢出异常 （#O） . . . . .4-21
4.9.1.5 数字下溢异常 （#U） . .. . .4-22
4.9.1.6 不准确结果（精度）异常（#P）。 . . .4-23
4.9.2 浮点异常优先级 。 . . . . .4-24
4.9.3 浮点异常处理程序的典型操作 。 ..4-24

第 5 章
指令集摘要
5.1 通用说明 . . . . .5-3
5.1.1 数据传输说明 .  .. . ..5-3
5.1.2 二进制算术指令。  . . . .5-4
5.1.3 十进制算术指令 .  . . . . .5-4
5.1.4 逻辑指令 . . . . . .5-4
5.1.5 换档和旋转说明 。  .. . . .5-4
5.1.6 位和字节说明 。  . . . . . .5-5
5.1.7 控制传输说明 .  .. . . .5-5
5.1.8 字符串指令 . . . . . . .5-6
5.1.9 I/O 说明 . . . . . .5-7
5.1.10 输入和离开说明 。  .. . . .5-7
5.1.11 标志控制 （EFLAG） 说明 。 . . . ..5-7
5.1.12 段寄存器说明 .  . . . . . .5-7
5.1.13 杂项说明 .  .. . ..5-8
5.1.14 用户模式扩展 Sate 保存/恢复说明 。. . . . .5-8
5.1.15 随机数生成器指令 . .. . . . .5-8
5.1.16 BMI1， BMI2 . . . . .5-8
5.1.16.1 检测 VEX 编码的 GPR 指令、LZCNT 和 TZCNT，PREFETCHW 。 . . . . .5-9
5.2 X87 FPU 指令 .  . . . . .5-9
5.2.1 x87 FPU 数据传输说明 .  . . . .5-9
5.2.2 x87 FPU 基本算术指令 . . . . . .5-9
5.2.3 x87 FPU 比较说明 . . . . . .5-10
5.2.4 x87 FPU 超越说明 . . . . .5-11
5.2.5 x87 FPU 负载常量指令 . . . . .5-11
5.2.6 x87 FPU 控制说明 .  . ..5-11
5.3 X87 FPU 和 SIMD 状态管理说明 . . .5-12
5.4 MMX 指令 . . . .5-12
5.4.1 MMX 数据传输说明 . . . . .5-12
5.4.2 MMX 转换说明 .  . ..5-12
5.4.3 MMX 包装算术指令 . . . . . .5-13
5.4.4 MMX 比较说明 .  . . . . .5-13
5.4.5 MMX 逻辑指令 .  . . . .5-13
5.4.6 MMX 换档和旋转说明 .  . . .5-13
5.4.7 MMX 国家管理说明 . . . . .5-14
5.5 SSE 指令 .. ..5-14
5.5.1 SSE SIMD 单精度浮点指令 .. ..5-14
5.5.1.1 SSE数据传输说明 。 . . ..5-14
5.5.1.2 SSE 包装算术指令 . .. . .5-15
5.5.1.3 SSE 比较说明 . . . . .5-15
5.5.1.4 SSE 逻辑指令 .  .. . . .5-15
5.5.1.5 SSE 洗牌和解压缩说明 . .. . . .5-15
5.5.1.6 SSE 转换说明 .  . . . .5-16
5.5.2 SSE MXCSR 国家管理说明 。 . . . .5-16
5.5.3 SSE 64 位 SIMD 整数指令 . . . . .5-16
5.5.4 SSE 可缓存性控制、预取和指令订购说明 . .5-16
5.6 SSE2 指令 . . . . .5-17
5.6.1 SSE2 包装和标量双精度浮点指令 . . .5-17
5.6.1.1 SSE2 数据移动说明 . . . . .5-17
5.6.1.2 SSE2 打包算术指令 . .. . . .5-18
5.6.1.3 SSE2 逻辑指令 .  .. ..5-18
5.6.1.4 SSE2 比较说明 .  . . . . .5-18
5.6.1.5 SSE2 洗牌和解包说明 . . ..5-18
5.6.1.6 SSE2 转换说明 . . . . . .5-19
5.6.2 SSE2 封装单精度浮点指令 . . . .5-19
5.6.3 SSE2 128位SIMD整数指令 . .. . . .5-19
5.6.4 SSE2 可缓存性控制和订购说明 。. . . .5-20
5.7 SSE3 指令 . . . . .5-20
5.7.1 SSE3 x87-FP 整数转换指令 . . . .5-20
5.7.2 SSE3 专用 128 位未对齐数据加载指令 。 . . . .5-20
5.7.3 SSE3 SIMD 浮点封装 ADD/SUB 指令 . . .5-21
5.7.4 SSE3 SIMD 浮点水平ADD/SUB指令. . ..5-21
5.7.5 SSE3 SIMD 浮点 LOAD/移动/重复说明 .. . .5-21
5.7.6 SSE3 代理同步说明 . . ..5-21
5.8 补充式扫描扩展 3 （SSSE3） 说明 。  . ..5-21
5.8.1 水平加法/减法 。 . . . .5-22
5.8.2 包装绝对值 .  . . . . .5-22
5.8.3 乘以和添加打包的带符号和未签名字节。. ..5-22
5.8.4 包装乘以高与圆和刻度 。 . . . .5-22
5.8.5 打包随机播放字节 。  . . ..5-23
5.8.6 包装符号 .. . . .5-23
5.8.7 打包 对齐右侧 . . . .5-23
5.9 SSE4 指令 . . . . .5-23
5.10 SSE4.1 指令 .  . . . .5-24
5.10.1 Dword 乘法指令 .  .. ..5-24
5.10.2 浮点点产品说明。 .. . . .5-24
5.10.3 流负载提示指令 . . . . .5-24
5.10.4 包装混合说明 .  . ..5-24
5.10.5 包装整数 MIN/MAX 说明 . . . . .5-24
5.10.6 具有可选舍入模式的浮点圆指令 。. ..5-25
5.10.7 从XMM寄存器中插入和提取。 . ..5-25
5.10.8 包装整数格式转换 . . . . . .5-25
5.10.9 4 字节块的绝对差异总和 （SAD）。. . . .5-26
5.10.10 水平搜索 . . . . . .5-26
5.10.11 包装测试 .. . . .5-26
5.10.12 包装 Qword 相等性比较 . . . . .5-26
5.10.13 无符号饱和度的 Word 包装 。 . ..5-26
5.11 SSE4.2 指令集 . . .5-26
5.11.1 字符串和文本处理说明 。 .. ..5-26
5.11.2 打包比较 SIMD 整数指令 . . . .5-27
5.12 AESNI 和 PCLMULQQQ .  . . ..5-27
5.13 英特尔高级扩展 （INTEL AVX） .. . . .5-27
5.14 16 位浮点转换 . . . . . .5-27
5.15 FUSED-乘法-ADD （FMA） .  .. . . .5-28
5.16 英特尔高级扩展 2 （INTEL AVX2） . . .5-28
5.17 英特尔交易扩展 （INTEL TSX） .  . . .5-28
5.18 英特尔 SHA 扩展 . . .5-28
5.19 英特尔高级扩展 512 （INTEL AVX-512） . . . .5-28
5.20 系统说明 .  . . . . .5-32
5.21 64-BIT 模式说明 .  .. . .5-33
5.22 虚拟-机器扩展 .  . . . . .5-34
5.23 SAFER 模式扩展 。  . . . . .5-34
5.24 英特尔内存保护扩展 。 .. ..5-35
5.25 英特尔软件护展扩展 。 . . . .5-35
第 6 章
程序呼叫、中断和异常
6.1 过程调用类型 。  . . ..6-1
6.2 堆栈 . . ..6-1
6.2.1 设置堆栈 . . . . . .6-2
6.2.2 堆栈对齐 . . . . . . .6-2
6.2.3 堆栈访问的地址大小属性 。 . . . . . .6-3
6.2.4 程序链接信息 .  . . . . . .6-3
6.2.4.1 堆栈帧基本指针 .  . . . .6-3
6.2.4.2 返回指令指针 .  . . . .6-3
6.2.5 64 位模式下的堆栈行为 。  . . . . . .6-4
6.3 使用呼叫和呼叫调用程序 。 . ..6-4
6.3.1 接近呼叫和 RET 操作 。  . . . .6-4
6.3.2 远呼叫和 RET 操作 .  .. . . .6-4
6.3.3 参数传递 . . . . . . .6-5
6.3.3.1 通过通用寄存器传递参数 。. . ..6-5
6.3.3.2 在堆栈上传递参数 。  . . . .6-5
6.3.3.3 在参数列表中传递参数 。 . . . . . .6-6
6.3.4 保存程序状态信息 。  . . . .6-6
6.3.5 调用其他特权级别 。  . . . .6-6
6.3.6 特权级别之间的呼叫和 RET 操作 。 . . . .6-7
6.3.7 分支函数在 64 位模式下 。 . . . ..6-9
6.4 中断和异常 。  .. ..6-9
6.4.1 中断或异常处理程序的呼叫和返回操作 。  . . . .6-10
6.4.2 调用中断或异常处理程序任务 。 . . . .6-13
6.4.3 在实地址模式下的中断和异常处理 . . .6-13
6.4.4 INT n、INT3、INT1 和 BOUND 说明 。 . . . .6-13
6.4.5 处理浮点异常 。  . . .6-14
6.4.6 64位模式下的中断和异常行为。 . . . .6-14
6.5 程序要求块结构化语言 . . .6-14
6.5.1 输入指令 . . . . .6-15
6.5.2 离开指令 . . . . .6-19
第七章
使用通用说明的编程
7.1 GP 指示的编程环境 。. . .7-1
7.2 在 64-BIT 模式下为 GP 指令编程环境 . . .7-1
7.3 GP 指示的摘要 .  . ..7-2
7.3.1 数据传输说明 .  .. . ..7-2
7.3.1.1 一般数据移动说明 。 .. . . . .7-3
7.3.1.2 交流说明 .  . . . . .7-4
7.3.1.3 64 位模式下的交换指令 。 .. . . . .7-5
7.3.1.4 堆栈操作说明 . . . . . . .7-5
7.3.1.5 64 位模式下的堆栈操作指令 。 . . . . .7-7
7.3.1.6 类型转换说明 . . . . ..7-7
7.3.1.7 64 位模式下的类型转换说明 。 . . . .7-8
7.3.2 二进制算术指令。  . . . .7-8
7.3.2.1 加减说明 . .. . . . .7-8
7.3.2.2 增量和递减说明 。 .. . . .7-8
7.3.2.3 64 位模式下的增量和递减说明 . . . .7-8
7.3.2.4 比较和符号更改说明 。 . . . . .7-8
7.3.2.5 乘法和除法说明 。 .. . . .7-9
7.3.3 十进制算术指令 .  . . . . . .7-9
7.3.3.1 包装的 BCD 调整说明 . .. . . . .7-9
7.3.3.2 未包装的 BCD 调整说明 . . . . .7-9
7.3.4 64 位模式下的十进制算术指令 。 . ..7-10
7.3.5 逻辑指令 。  . . . .7-10
7.3.6 换档和旋转指令 .  . ..7-10
7.3.6.1 换档说明 .  . . . . .7-10
7.3.6.2 双移说明 。  .. ..7-12
7.3.6.3 旋转指令 . . .7-13
7.3.7 位和字节说明 。  . . . .7-13
7.3.7.1 位测试和修改说明 。  . . .7-14
7.3.7.2 位扫描说明 .  . . . . .7-14
7.3.7.3 条件说明上的字节设置 。 . . . .7-14
7.3.7.4 测试说明 .  . . . .7-14
7.3.8 控制传输说明 .  . ..7-14
7.3.8.1 无条件转移指令 . .. . .7-14
7.3.8.2 条件转移指令 . . . . . .7-15
7.3.8.3 64 位模式下的控制传输指令 。 . . .7-17
7.3.8.4 软件中断说明 .  . . .7-17
7.3.8.5 64 位模式和兼容性模式下的软件中断指令 。  . . . .7-18
7.3.9 字符串操作 . . . . . . .7-18
7.3.9.1 字符串指令 .  . . ..7-18
7.3.9.2 重复字符串操作 .  . . . .7-19
7.3.9.3 快速字符串操作 .  . . . .7-19
7.3.9.4 64 位模式下的字符串操作 。 . . . . .7-20
7.3.10 I/O 说明 . . ..7-20
7.3.11 64 位模式下的 I/O 指令 。  . . . .7-20
7.3.12 输入和离开说明 。  . ..7-21
7.3.13 标志控制 （EFLAG） 说明 。 . . . . .7-21
7.3.13.1 携带和方向标志说明 。 .. . . .7-21
7.3.13.2 EFLAGS 传输说明 . . . . . .7-21
7.3.13.3 中断标志说明 .  . . . . .7-22
7.3.14 64 位模式下的标记控制 （RFLAG） 指令 。 . . . .7-22
7.3.15 段寄存器说明 .  . . . .7-22
7.3.15.1 段-寄存器负载和存储说明 。 . . .7-22
7.3.15.2 远控制传输说明 . . . . . .7-22
7.3.15.3 软件中断说明 .  . . .7-23
7.3.15.4 负载远指针指令 . . . . .7-23
7.3.16 杂项说明 .  .. . . .7-23
7.3.16.1 地址计算指令 . . . . . .7-23
7.3.16.2 表查找说明 .  . ..7-23
7.3.16.3 处理器识别说明 . .. . .7-23
7.3.16.4 无操作和未定义指令 . . . .7-23
7.3.17 随机数生成器指令 . .. ..7-24
7.3.17.1 RDRAND .. . . .7-24
7.3.17.2 RDSEED .. . . . .7-24
第 8 章
使用 X87 FPU 编程
8.1 X87 FPU 执行环境 . . . . . .8-1
8.1.1 x87 FPU 在 64 位模式和兼容性模式 . . . . .8-1
8.1.2 x87 FPU 数据寄存器 .  . . . . . .8-1
8.1.2.1 参数通过 x87 FPU 寄存器堆栈 . . . . . .8-3
8.1.3 x87 FPU 状态寄存器 .  . . . . . .8-4
8.1.3.1 堆栈顶部 （TOP） 指针 .  . . . .8-4
8.1.3.2 条件代码标志 .  . . . . . .8-4
8.1.3.3 x87 FPU 浮点异常标志 . . . . . . .8-5
8.1.3.4 堆栈故障标志 . . . . .8-6
8.1.4 条件代码上的分支和条件移动 。. . . . .8-6
8.1.5 x87 FPU 控制字 .  . . . . .8-7
8.1.5.1 x87 FPU 浮点异常掩码位 . . . . .8-7
8.1.5.2 精密控制场 .  . . . . .8-7
8.1.5.3 舍入控制场 .  . . . . .8-8
8.1.6 无限控制标志 . . . . . . .8-8
8.1.7 x87 FPU 标记字 . . . . .8-8
8.1.8 x87 FPU 指令和数据（操作）指针 . . . . . .8-9
8.1.9 最后一个指令操作码 .  . . . . .8-10
8.1.9.1 Fopcode 兼容性子模式 。 . . . . .8-10
8.1.10 使用 FSTENV/FNSTENV 和 FSAVE/FNSAVE . 保存 x87 FPU 的状态 。8-11
8.1.11 使用 FXSAVE 保存 x87 FPU 的状态。 . ..8-12
8.2 X87 FPU 数据类型 .  . . . .8-13
8.2.1 不确定 .. . . . .8-14
8.2.2 不支持双扩展精度浮点编码和伪非正态。 ..8-14
8.3 X87 FPU 指令设置 .  . . . .8-15
8.3.1 转义 （ESC） 说明 .  .. . .8-15
8.3.2 x87 FPU 指令操作器 .  . . . .8-15
8.3.3 数据传输说明 .  .. . . .8-16
8.3.4 加载恒定指令 。  .. . . .8-17
8.3.5 基本算术指令 。  . ..8-17
8.3.6 比较和分类说明 . . . . . .8-18
8.3.6.1 在 x87 FPU 条件代码上的分支 。 . ..8-20
8.3.7 三角指令 .  .. . . .8-20
8.3.8 Pi 的近似值 。  . . . . .8-21
8.3.9 对数、指数和缩放 。  . . .8-21
8.3.10 超越指令精度 . . . . .8-22
8.3.11 x87 FPU 控制说明 .  . ..8-23
8.3.12 等待与非等待说明 。 . . . . .8-24
8.3.13 不支持 x87 FPU 说明 .  . . .8-24
8.4 X87 FPU 浮点异常处理 . . . .8-24
8.4.1 算术与非算术指令 。 . . . . .8-25
8.5 X87 FPU 浮动点 . . .8-26
8.5.1 无效操作异常 。  .. ..8-26
8.5.1.1 堆栈溢出或下溢异常 （#IS） 。 . . . .8-26
8.5.1.2 无效算术操作数异常 （#IA） . . ..8-27
8.5.2 非正常操作器异常 （#D） . . . ..8-28
8.5.3 除零例外 （#Z） .  . . . .8-28
8.5.4 数字溢出异常 （#O） . . . ..8-29
8.5.5 数字下溢异常 （#U） .  . . .8-29
8.5.6 不准确结果（精度）异常（#P）。 . ..8-30
8.6 X87 FPU 异常已实现 . .. . .8-31
8.7 处理 X87 FPU 软件异常 。 . . . .8-32
8.7.1 本机模式 .. . . .8-32
8.7.2 MS-DOS? 兼容性子模式 . . . . . .8-32
8.7.3 处理软件中的 x87 FPU 异常 。 . . . . .8-33
第 9 章
使用英特尔 MMX 技术进行编程
9.1 MMX 技术概述 .  . . . . .9-1
9.2 MMX 技术编程环境 .. ..9-1
9.2.1 MMX 技术在 64 位模式和兼容性模式 . . . .9-2
9.2.2 MMX 寄存器 . . . . . .9-2
9.2.3 MMX 数据类型 .. . . .9-3
9.2.4 内存数据格式 .  . . . . .9-3
9.2.5 单指令，多数据 （SIMD） 执行模型 . . . .9-4
9.3 饱和和环绕模式 。 .. . .9-4
9.4 MMX 指示 .. ..9-5
9.4.1 数据传输说明 .  .. . ..9-6
9.4.2 算术指令 .  . . . . .9-6
9.4.3 比较说明 . . . . . .9-7
9.4.4 转换说明 . . . . . . .9-7
9.4.5 解包说明 . . . . .9-7
9.4.6 逻辑指令 . . . . . .9-7
9.4.7 换档说明 .. . . .9-8
9.4.8 EMMS 指令 .. . . .9-8
9.5 与 X87 FPU 结构的兼容性 。 . . . .9-8
9.5.1 MMX 说明和 x87 FPU 标记字 。 . . ..9-8
9.6 使用 MMX 代码书写应用程序 。 . . . .9-8
9.6.1 检查 MMX 技术支持 。 .. . ..9-8
9.6.2 x87 FPU 和 MMX 代码之间的转换 。 . . ..9-9
9.6.3 使用 EMMS 指令 .  .. . . . .9-9
9.6.4 混合 MMX 和 x87 FPU 说明 . .. . .9-10
9.6.5 与 MMX 代码连接 。  .. . . .9-10
9.6.6 在多任务操作系统环境中使用 MMX 代码 。. ..9-10
9.6.7 MMX 代码中的异常处理 。 . . . . .9-11
9.6.8 注册映射 . . . . . .9-11
9.6.9 指令前缀对MMX指令的影响。. . .9-11
第10章
使用英特尔流式处理扩展（英特尔 SSE）进行编程
10.1 上证所扩展概述 。  . ..10-1
10.2 SSE 编程环境 . . . . . .10-2
10.2.1 SSE在64位模式和兼容性模式。 . . . .10-3
10.2.2 XMM 寄存器 . . . ..10-3
10.2.3 MXCSR 控制和状态寄存器 。  . . .10-3
10.2.3.1 SIMD 浮点掩码和标志位 。 . . . . .10-4
10.2.3.2 SIMD 浮点圆周控制场 . . ..10-4
10.2.3.3 刷新至零 . . . . .10-4
10.2.3.4 非常值-是-零 。  . . . .10-5
10.2.4 上证所扩展与上交所2/SSE3/MMX和x87 FPU的兼容性。  . ..10-5
10.3 SSE 数据类型 . . . . . . .10-5
10.4 SSE 指令集 .  . . . .10-6
10.4.1 SSE 包装和标量浮点说明 . . . .10-6
10.4.1.1 SSE 数据移动说明 . . . . . .10-7
10.4.1.2 SSE算术指令 .  . . . .10-8
10.4.2 SSE 逻辑指令 .  . . . . .10-9
10.4.2.1 SSE 比较说明 . . . . .10-9
10.4.2.2 SSE 随机播放和解压缩说明 。 .. . . .10-9
10.4.3 SSE 转换说明 .  . ..10-11
10.4.4 上证64位SIMD整数指令 . .. . .10-11
10.4.5 MXCSR 国家管理说明 。 .. ..10-12
10.4.6 可缓存性控制、预取和内存排序说明 。 ..10-12
10.4.6.1 可缓存性控制说明 . . . . .10-12
10.4.6.2 时间与非时态数据的缓存 。 . . . .10-12
10.4.6.3 PREFETCHh 说明 .  . ..10-13
10.4.6.4 SFENCE 指令 .  . . . . .10-14
10.5 外汇储蓄和外汇说明 . . . . .10-14
10.5.1 FXSAVE 区域 . . . ..10-14
10.5.1.1 x87 状态 . . . . .10-15
10.5.1.2 SSE 状态 . . . . . .10-16
10.5.2 FXSAVE 操作 . . . .10-16
10.5.3 FXRSTOR 的操作 .  . . . .10-17
10.6 处理 SSE 指令异常 。 . ..10-17
10.7 使用 SSE 扩展进行写入应用 。. . .10-17
第11章
使用英特尔流式扩展 2 （INTEL SSE2） 编程
11.1 SSE2 扩展的概述 。  . . . .11-1
11.2 SSE2 编程环境 . . . ..11-2
11.2.1 SSE2 在 64 位模式和兼容性模式 . . . .11-3
11.2.2 SSE2 扩展与 SSE、MMX 技术和 x87 FPU 编程环境的兼容性 。.11-3
11.2.3 非正常-是-零标志 。  .. . . .11-3
11.3 SSE2 数据类型 . . . ..11-3
11.4 SSE2 指令 . . . .11-4
11.4.1 包装和标量双精度浮点指令 。. . .11-4
11.4.1.1 数据移动说明 . . . . .11-5
11.4.1.2 SSE2 算术指令 . . . . .11-6
11.4.1.3 SSE2 逻辑指令 .  . ..11-7
11.4.1.4 SSE2 比较说明 . . . . . .11-7
11.4.1.5 SSE2 洗牌和解包说明 . . ..11-7
11.4.1.6 SSE2 转换说明 . . . . . .11-9
11.4.2 SSE2 64 位和 128 位 SIMD 整数指令 .. . . .11-10
11.4.3 128 位 SIMD 整数指令扩展 。 . . . .11-11
11.4.4 可缓存性控制和内存排序说明 . . .11-12
11.4.4.1 FLUSH 缓存行 . . . .11-12
11.4.4.2 可缓存性控制说明 . . . . .11-12
11.4.4.3 内存订购说明 . . . ..11-12
11.4.4.4 暂停 。 . . .11-12
11.4.5 分支提示 . . . . . . .11-13
11.5 上证所、上证所和深证成指。 . . . . .11-13
11.5.1 SIMD 浮点异常 。 . . . . .11-13
11.5.2 SIMD 浮点异常条件 . . . . . .11-14
11.5.2.1 无效操作异常 （#I） 。 . . . . .11-14
11.5.2.2 非正常-操作异常 （#D） . .. . . .11-15
11.5.2.3 除以零例外 （#Z） .  . . .11-15
11.5.2.4 数字溢出异常 （#O） . .. . .11-15
11.5.2.5 数字下溢异常 （#U） . .. . . .11-16
11.5.2.6 不准确结果（精度）异常（#P）。 . . . .11-16
11.5.3 生成 SIMD 浮点异常 。 . . .11-16
11.5.3.1 处理屏蔽异常 。 . . . . .11-16
11.5.3.2 处理未屏蔽异常 。 . . . . .11-17
11.5.3.3 处理屏蔽和未屏蔽异常的组合 。. ..11-18
11.5.4 处理软件中的 SIMD 浮点异常 。 ..11-18
11.5.5 SIMD 和 x87 FPU 浮点异常的交互 . . .11-18
11.6 使用 SSE/SSE2 扩展进行写入应用 。. ..11-19
11.6.1 使用 SSE/SSE2 扩展的一般准则 。. . . .11-19
11.6.2 检查上证/深交所2支持。 . . . . .11-19
11.6.3 在 MXCSR 寄存器中检查 DAZ 标志 。. . .11-20
11.6.4 上证所/深证2号扩展的初增。 .. . .11-20
11.6.5 保存和恢复上证所/深证2州。 . . . . .11-20
11.6.6 写入 MXCSR 注册指南 。 . ..11-21
11.6.7 SSE/SSE2 指令与 x87 FPU 和 MMX 指令的交互作用 。  . . .11-21
11.6.8 SIMD 和 x87 FPU 浮点数据类型的兼容性 。. . .11-22
11.6.9 混合包装和标量浮点和 128 位 SIMD 整数指令和数据 。 . . .11-22
11.6.10 与上证所/深交所2程序和功能接口。 ..11-23
11.6.10.1 XMM 寄存器中的传递参数 . . . . . .11-23
11.6.10.2 在程序或函数调用上保存 XMM 寄存器状态 。. . .11-23
11.6.10.3 程序调用和函数调用的调用方保存建议 。 ..11-24
11.6.11 使用 128 位 SIMD 整数指令更新现有 MMX 技术例程 . . .11-24
11.6.12 算术运算分支 . . . . .11-24
11.6.13 可缓存提示说明 .  . . . . .11-25
11.6.14 指令前缀对上交所/SSE2 指令的影响 . . .11-25
第12章
使用英特尔 SSE3、SSSE3、INTEL SSE4 和 INTEL AESNI 编程
12.1 编程环境和数据类型 。 . ..12-1
12.1.1 SSE3，SSSE3，SSE4 在64位模式和兼容性模式。 . . . .12-1
12.1.2 SSE3/SSSE3 与 MMX 技术、x87 FPU 环境和 SSE/SSE2 扩展的兼容性 。.12-1
12.1.3 水平和非对称处理 . .. . .12-1
12.2 SSE3 指令概述 。 . . . . .12-2
12.3 SSE3 指令 . . . . .12-2
12.3.1 x87 FPU 指令，用于整数转换 。 . . . .12-3
12.3.2 专用 128 位未对齐数据加载的 SIMD 整数指令 。  . . .12-3
12.3.3 SIMD 浮点指令，可增强 LOAD/MOVE/DUPLICATE 性能 。 ..12-3
12.3.4 SIMD 浮点指令提供包装加法/减法 。  . . .12-4
12.3.5 SIMD 浮点指令提供水平加法/减法 . . .12-4
12.3.6 两个线程同步指令 。 . ..12-5
12.4 使用 SSE3 扩展进行写入应用 。 . ..12-5
12.4.1 使用 SSE3 扩展的指南 。 . . . .12-5
12.4.2 检查 SSE3 支持 。  .. . . .12-5
12.4.3 启用 FTZ 和 DAZ 以进行 SIMD 浮点计算 。 . . . .12-6
12.4.4 编程 SSE3 与 SSE/SSE2 扩展 . . ..12-6
12.5 SSSE3 指令概述 。 . . ..12-6
12.6 SSSE3 说明 . . . .12-6
12.6.1 水平加法/减法 。 . . . .12-7
12.6.2 包装绝对值 .  . . . . .12-7
12.6.3 乘以和添加打包的带符号和未签名字节 。. ..12-8
12.6.4 包装乘以高与圆和刻度 。 . . . .12-8
12.6.5 打包随机播放字节 。  . . ..12-8
12.6.6 包装符号 .. . . .12-8
12.6.7 打包对齐右侧 . . . .12-8
12.7 使用 SSSE3 扩展件进行写入应用 。 . . .12-9
12.7.1 使用 SSSE3 扩展的指南 。 .. . .12-9
12.7.2 检查 SSSE3 支持 。  .. ..12-9
12.8 SSE3/SSSE3 和 SSE4 例外 . . . . . .12-9
12.8.1 设备不可用 （DNA） 异常 。 .. . .12-9
12.8.2 数值错误标志和 IGNNE* 。  . . . .12-9
12.8.3 仿真 .. . . . .12-10
12.8.4 IEEE 754 符合 SSE4.1 浮点指令 。 . ..12-10
12.9 SSE4 概述 . . . ..12-10
12.10 SSE4.1 指令集 .  . . . .12-11
12.10.1 Dword 乘法指令 .  . ..12-11
12.10.2 浮点点产品说明。 .. ..12-11
12.10.3 流加载提示指令 . . . . . .12-12
12.10.4 包装混合说明 .  . . . . .12-14
12.10.5 包装整数 MIN/MAX 指令 . .. . .12-14
12.10.6 具有可选舍入模式的浮点圆指令 。 ..12-14
12.10.7 从XMM寄存器中插入和提取。 . . .12-15
12.10.8 打包整数格式转换 . . . . .12-15
12.10.9 4 字节块的绝对差异总和 （SAD）。. ..12-16
12.10.10 水平搜索 .  . . . .12-16
12.10.11 包装测试 . . . . .12-17
12.10.12 包装 Qword 相等比较 。 .. . .12-17
12.10.13 无符号饱和度的 Word 包装 。 . . . . .12-17
12.11 SSE4.2 指令集 .  . . . . .12-17
12.11.1 字符串和文本处理说明 。 . ..12-17
12.11.1.1 内存操作数对齐 . . . . . .12-18
12.11.2 打包比较 SIMD 整数指令 . . . . .12-18
12.12 使用 SSE4 扩展进行写入应用 。 . . .12-18
12.12.1 使用 SSE4 扩展的指南 。 .. . .12-18
12.12.2 检查 SSE4.1 支持 .  . . . . .12-19
12.12.3 检查 SSE4.2 支持 .  . . . . .12-19
12.13 AESNI 概述 . . ..12-19
12.13.1 小端建筑和大内规范 （FIPS 197） . . . .12-19
12.13.1.1 英特尔 64 架构中的 AES 数据结构 . . . .12-20
12.13.2 AES 转换和函数 . . . . .12-21
12.13.3 PCLMULQQQ . . . . . .12-24
12.13.4 检查 AESNI 支持 。  . ..12-25
第13章
使用 XSAVE 功能集管理状态
13.1 XSAVE 支持的功能和状态-组件 BITMAPS 。. . . .13-1
13.2 为 XSAVE 指令和 XSAVE 支持的功能提供 CPU 支持。  ..13-3
13.3 启用 XSAVE 功能集和 XSAVE 启用功能 . . .13-4
13.4 XSAVE AREA . . . .13-6
13.4.1 XSAVE 区域的旧区 。 . . ..13-6
13.4.2 XSAVE 头 . . . ..13-7
13.4.3 XSAVE 区域的扩展区域 。 . . . . .13-8
13.5 XSAVE 管理状态 . . .13-8
13.5.1 x87 状态 . . . .13-9
13.5.2 SSE 州 . . . .13-9
13.5.3 AVX 状态 .. . . .13-10
13.5.4 MPX 状态 .. . . .13-10
13.5.5 AVX-512 状态 .. ..13-11
13.5.6 PT 状态 . . . .13-12
13.5.7 PKRU 状态 . . . . .13-12
13.5.8 HDC 状态 .. . . . .13-13
13.6 XSAVE 管理状态的处理器跟踪 。. . .13-13
13.7 XSAVE 的操作 .  . . . . .13-14
13.8 XRSTOR 的操作 . . . .13-15
13.8.1 XRSTOR 的标准形式 .  .. ..13-15
13.8.2 XRSTOR 的压缩形式 .  . . . . .13-16
13.8.3 XRSTOR 和自生自来和修改优化 . . . .13-16
13.9 XSAVEOPT 的操作 .  .. . .13-17
13.10 XSAVEC 的操作 . . . .13-18
13.11 XSAVES 的操作 . . . .13-19
13.12 XRSTORS 的运行 。  . . . . .13-20
13.13 记忆访问 XSAVE 功能集 . . . . .13-21
第14章
使用 AVX、FMA 和 AVX2 进行编程
14.1 英特尔 AVX 概述 .  . . . .14-1
14.1.1 256 位宽 SIMD 寄存器支持 . . . . .14-1
14.1.2 指令语法增强。 . . ..14-2
14.1.3 VEX 前缀指令编码支持 。 . ..14-2
14.2 功能概述 .  . . ..14-3
14.2.1 256 位浮点算术处理增强 . . .14-9
14.2.2 256 位非算术指令增强 。. . .14-9
14.2.3 用于 128 位矢量和 Scalar 处理的算术基元。. . .14-11
14.2.4 128 位矢量和标量处理的非算术基元 . . .14-13
14.3 检测 AVX 指示 .  . . .14-15
14.3.1 VEX 编码 AES 和 VPCLMULQDQ 的检测 。. . . .14-17
14.4 半精度浮点转换 。 . . .14-18
14.4.1 检测 F16C 指令 . . . . .14-20
14.5 FUSED-乘法-ADD（FMA）扩展。 . ..14-21
14.5.1 FMA 指令操作顺序和算术行为 。 . . .14-22
14.5.2 熔融-乘法-ADD （FMA） 数值行为。 . . . .14-22
14.5.3 FMA 检测 . . . . .14-24
14.6 英特尔高级扩展 2 （INTEL AVX2） 概述 . .14-25
14.6.1 AVX2 和 256 位矢量整数处理 。 . ..14-25
14.7 在 AVX2 中推广了 VECTOR INTEGER 指令。 ..14-26
14.7.1 检测 AVX2 .  . . . .14-31
14.8 访问 YMM 注册码 .  .. ..14-32
14.9 内存对齐 。  . . . . .14-32
14.10 SIMD 浮动点异常 。  . . .14-34
14.11 仿真 .. . . . .14-34
14.12 写入 AVX 浮动点 处理器 . . .14-34
14.13 通用说明设置增强 ... . .14-35
第15章
使用英特尔 AVX-512 编程
15.1 概述 .. . . . .15-1
15.1.1 512 位宽 SIMD 寄存器支持 . . . . . .15-1
15.1.2 32 SIMD 寄存器支持 .  .. . .15-1
15.1.3 八个操作码寄存器支持 。  . . . .15-1
15.1.4 指令语法增强。 . . . . .15-2
15.1.5 EVEX 指令编码支持 .  . . .15-3
15.2 检测 AVX-512 基础指令 .. . . .15-3
15.2.1 英特尔 AVX-512 系列的其他 512 位指令扩展。  . . . .15-4
15.3 检测英特尔 AVX-512 家庭 512-BIT 指令组 . .15-5
15.4 检测英特尔 AVX-512 指令组，操作于 256 和 128-BIT 矢量长度 。.15-6
15.5 访问 XMM、YMM 和 ZMM 寄存器 。 . ..15-8
15.6 使用 EVEX 编码 的增强矢量编程环境 。  . . . .15-8
15.6.1 OPMASK 寄存器到谓词矢量数据处理 . . . . .15-9
15.6.1.1 操作框寄存器 K0 .  . . . . .15-9
15.6.1.2 操作框用法示例 。 . . . .15-10
15.6.2 操作框说明 .  . . ..15-11
15.6.3 广播 .. . . . .15-11
15.6.4 静态舍入模式和抑制所有异常 。. . . .15-12
15.6.5 压缩 Disp8_N 编码 . . . . .15-13
15.7 内存对齐 。  . . . . .15-13
15.8 SIMD 浮动点异常 。  . . .15-14
15.9 指令异常规范。 .. ..15-15
15.10 仿真 .. . . . .15-15
15.11 写入浮动点 . . .15-15
第16章
与英特尔的编程
16.1 概述 .. . . . .16-1
16.2 英特尔已同步扩展 . . .16-1
16.2.1 HLE 软件接口 .  . . . . .16-2
16.2.2 RTM 软件接口 .  . . . .16-3
16.3 英特尔 TSX 应用编程型号 . . ..16-3
16.3.1 检测事务同步支持 。. . . .16-3
16.3.1.1 HLE 支持的检测 .  . ..16-3
16.3.1.2 检测 RTM 支持 。  . . . . .16-3
16.3.1.3 XTEST 指令的检测 .  . . .16-3
16.3.2 查询事务执行状态 。 . ..16-4
16.3.3 HLE 锁的要求 .  . ..16-4
16.3.4 事务嵌套 . . . .16-4
16.3.4.1 HLE 嵌套和消除 。  .. . . .16-4
16.3.4.2 RTM 嵌套 .. ..16-5
16.3.4.3 嵌套 HLE 和 RTM .  . . . .16-5
16.3.5 RTM 中止状态定义 .  . ..16-5
16.3.6 RTM 内存订购 . . . .16-5
16.3.7 支持 RTM 的调试器支持 。 . . . .16-6
16.3.8 编程注意事项 .  . ..16-6
16.3.8.1 基于指令的注意事项 。 . . . . .16-6
16.3.8.2 运行时注意事项 .  .. . . .16-7
第17章
英特尔内存保护扩展
17.1 英特尔内存保护扩展 （INTEL MPX） . . .17-1
17.2 介绍 .. . . .17-1
17.3 英特尔 MPX 编程环境 . .. ..17-1
17.3.1 英特尔 MPX 接口的检测和枚举 .. . . .17-2
17.3.2 边界寄存器 . . . . . .17-2
17.3.3 配置和状态寄存器 。  . . .17-3
17.3.4 IA32_BNDCFGS 的读写 。 . . ..17-4
17.4 英特尔 MPX 指令摘要 . . . ..17-4
17.4.1 指令编码 .  . . . . .17-5
17.4.2 用法和示例 。  . . . . .17-5
17.4.3 在内存中加载和存储边界 。 .. . . .17-6
17.4.3.1 BNDLDX 和 BNDSTX 在 64 位模式 . .. ..17-7
17.4.3.2 BNDLDX 和 BNDSTX 64 位模式外 。 . ..17-8
17.5 与 INTEL MPX 的交互 。  . . . . .17-9
17.5.1 英特尔 MPX 和操作模式 . . . . .17-9
17.5.2 英特尔 MPX 支持具有分支指针操作 。 . . . .17-10
17.5.3 呼叫、RET、JMP 和所有 Jcc 。  .. . . .17-10
17.5.4 BOUND 指令和英特尔 MPX .  . . .17-11
17.5.5 编程注意事项 .  . . . . .17-11
17.5.6 英特尔 MPX 和系统管理模式 . . . . .17-11
17.5.7 支持英特尔 MPX 在 VMCS 中 .  . . . .17-11
17.5.8 英特尔 MPX 在英特尔 TSX 中的支持 。 . . ..17-12
第18章
输入/输出
18.1 I/O 端口地址 。  . . . .18-1
18.2 I/O 端口硬件 . . . . .18-1
18.3 I/O 地址空间 . . . . .18-1
18.3.1 内存映射 I/O 。  . . . . .18-2
18.4 I/O 说明 . . ..18-3
18.5 保护模式 I/O 。  . . . .18-3
18.5.1 I/O 特权级别 . . . .18-3
18.5.2 I/O 权限位映射 . . . .18-4
18.6 订购 I/O .. . . . .18-5
第19章
处理器识别和功能确定
19.1 使用 CPUID 指令 。  . ..19-1
19.1.1 关于从哪里开始的说明。  . . . .19-1
19.1.2 早期 IA-32 处理器的标识 . . ..19-1


1.3.1 位和字节顺序
在内存中数据结构的插图中，较小的地址出现在图形的底部;地址
向顶部增加。位位置从右向左编号。设置位的数值等于
两个提升到位位置的功率。英特尔 64 和 IA-32 处理器是"小终端"机器;这意味着
单词的字节从最低显著字节开始编号。参见图 1-1。

1.3.2 保留位和软件兼容性
在许多寄存器和内存布局描述中，某些位被标记为保留。当位标记为
保留，这是必要的与未来的处理器兼容性，软件将这些位视为具有未来，
虽然未知，但效果。保留位的行为不仅应视为未定义，而且不可预测。
在处理保留位时，软件应遵循以下准则：
? 在测试包含此类位的寄存器的值时，不要依赖于任何保留位状态。
在测试之前屏蔽保留位。
? 存储到内存或寄存器时，不要依赖于任何保留位状态。
? 不要依赖于是否能够保留写入任何保留位的信息。
? 加载寄存器时，始终加载包含文档中指示的值（如果有）的预留位，或者
使用以前从同一寄存器读取的值重新加载它们。

1.3.2.1 指令操作数
当以符号方式表示指令时，将使用 IA-32 汇编语言的子集。在此子集中，
指令具有以下格式：
标签： 助记符参数1， 参数2， 参数3
其中：
? 标签是一个标识符，后跟冒号。
? 助记符是具有相同功能的指令操作代码类的保留名称。
? 操作数参数1、参数2和参数3是可选的。可能有从零到三
操作数，具体取决于操作代码。如果存在时，它们采用文本或数据标识符的形式
项目。操作数标识符是寄存器的保留名称，或假定分配给数据项
在程序的另一部分中声明（示例中可能不会显示）。
当算术或逻辑指令中存在两个操作数时，右侧操作数是源，左侧为操作数
操作是目标。
例如：
LOADREG： MOV EAX, SUBTOTAL
在此示例中，LOADREG 是一个标签，MOV 是操作代码的助记符标识符，EAX 是目标操作数，
和 SUBTOTAL 是源操作数。某些汇编语言按相反顺序放置源和目标。

The processor uses byte addressing. This means memory is organized and accessed as a sequence of bytes.
Whether one or more bytes are being accessed, a byte address is used to locate the byte or bytes memory. The range of memory that can be addressed is called an address space.
处理器使用字节寻址。这意味着内存以字节序列进行组织和访问。
无论访问一个或多个字节，都使用字节地址来定位字节或字节内存。可寻址的内存范围称为地址空间。

Virtually any operating system or executive designed to work with an IA-32 or Intel 64 processor will use the processor’s memory management facilities to access memory. 
These facilities provide features such as segmentation and paging, which allow memory to be managed efficiently and reliably. 
Memory management is described in detail in Chapter 3, “Protected-Mode Memory Management,” in the Intel? 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A. 
The following paragraphs describe the basic methods of addressing memory when memory management is used.
几乎任何设计为与 IA-32 或英特尔 64 处理器配合使用的操作系统或操作系统都将使用处理器的内存管理功能来访问内存。
这些设施提供分段和分页等功能，使内存能够高效可靠地进行管理。
内存管理在第 3 章"受保护模式内存管理"中详细介绍，在英特尔? 64 和 IA-32 体系结构软件开发人员手册（第 3A 卷）中。
以下段落描述了在使用内存管理时寻址内存的基本方法。

Flat memory model ― Memory appears to a program as a single, continuous address space (Figure 3-3). 
This space is called a linear address space. 
Code, data, and stacks are all contained in this address space. 
Linear address space is byte addressable, with addresses running contiguously from 0 to 2^32 - 1 (if not in 64-bit mode). 
An address for any byte in linear address space is called a linear address.
平面内存模型 C 内存在程序中显示为单个连续地址空间（图 3-3）。
此空间称为线性地址空间。
代码、数据和堆栈都包含在此地址空间中。
线性地址空间是可字节寻址的，地址从 0 到 2^32 - 1 连续运行（如果不是在 64 位模式下）。
线性地址空间中任何字节的地址称为线性地址。

Segmented memory model ― Memory appears to a program as a group of independent address spaces called segments. 
Code, data, and stacks are typically contained in separate segments. To address a byte in a segment, a program issues a logical address. 
This consists of a segment selector and an offset (logical addresses are often referred to as far pointers). 
The segment selector identifies the segment to be accessed and the offset identifies a byte in the address space of the segment. 
Programs running on an IA-32 processor can address up to 16,383 segments of different sizes and types, and each segment can be as large as 2^32 bytes.
Internally, all the segments that are defined for a system are mapped into the processor’s linear address space.
To access a memory location, the processor thus translates each logical address into a linear address. 
This translation is transparent to the application program.
The primary reason for using segmented memory is to increase the reliability of programs and systems. 
For example, placing a program’s stack in a separate segment prevents the stack from growing into the code or data space and overwriting instructions or data, respectively.
分段内存模型 C 内存在程序中显示为一组称为段的独立地址空间。
代码、数据和堆栈通常包含在单独的段中。要解决段中的字节问题，程序会发出逻辑地址。
它由段选择器和偏移量组成（逻辑地址通常称为远指针）。
线段选择器标识要访问的段，偏移量标识段地址空间中的字节。
在 IA-32 处理器上运行的程序可以处理多达 16383 个不同大小和类型的段，并且每个段可以高达 2^32 字节。
在内部，为系统定义的所有段都映射到处理器的线性地址空间。
因此，要访问内存位置，处理器会将每个逻辑地址转换为线性地址。
此转换对应用程序是透明的。
使用分段内存的主要原因是为了提高程序和系统的可靠性。
例如，将程序堆栈放在单独的段中可防止堆栈分别增长到代码或数据空间并覆盖指令或数据。

Real-address mode memory model ― This is the memory model for the Intel 8086 processor. 
It is supported to provide compatibility with existing programs written to run on the Intel 8086 processor. 
The realaddress mode uses a specific implementation of segmented memory in which the linear address space for the program and the operating system/executive consists of an array of segments of up to 64 KBytes in size each.
The maximum size of the linear address space in real-address mode is 2^20 bytes.
实址模式内存型号 C 这是英特尔 8086 处理器的内存型号。
支持它提供与编写在英特尔 8086 处理器上运行的现有程序的兼容性。
实址模式使用分段内存的特定实现，其中程序和操作系统/执行的线性地址空间由每个大小高达 64 KB 的段数组组成。
实地址模式下线性地址空间的最大大小为 2^20 字节。

